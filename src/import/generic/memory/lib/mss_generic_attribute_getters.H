/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/import/generic/memory/lib/mss_generic_attribute_getters.H $ */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2018,2019                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
// mss_generic_attribute_getters.H
#ifndef MSS_GENERIC_ATTR_GETTERS_H_
#define MSS_GENERIC_ATTR_GETTERS_H_

#include <fapi2.H>
#include <generic/memory/lib/utils/index.H>
#include <generic/memory/lib/utils/c_str.H>



namespace mss
{
namespace attr
{
///
/// @brief ATTR_MEM_DRAM_CWL getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency.
///
inline fapi2::ReturnCode get_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_DRAM_CWL, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_RDIMM_BUFFER_DELAY getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Delay due to the presence of a buffer, in number of clocks
///
inline fapi2::ReturnCode get_dimm_buffer_delay(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_RDIMM_BUFFER_DELAY, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_RDIMM_BUFFER_DELAY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_VPD_DQ_MAP getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  [Dimm DQ PIN] The map from the Dual Inline Memory Module (DIMM) Data (DQ) Pin to
/// the Module Package Data (DQ) Pinout
///
inline fapi2::ReturnCode get_mem_vpd_dq_map(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[72])
{
    uint8_t l_value[72] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_VPD_DQ_MAP, i_target, l_value) );
    memcpy(o_array, &l_value, 72);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_VPD_DQ_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_REORDER_QUEUE_SETTING getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Contains the settings for write/read reorder queue
///
inline fapi2::ReturnCode get_reorder_queue_setting(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_REORDER_QUEUE_SETTING, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_REORDER_QUEUE_SETTING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_2N_MODE getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Default value for 2N Mode from Signal Integrity. 0x0 = Invalid Mode, 0x01 = 1N Mode
/// , 0x02 = 2N Mode If value is set to 0x0 this indicate value was never initialized
/// correctly.
///
inline fapi2::ReturnCode get_mem_2n_mode(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_2N_MODE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_2N_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_EFF_DRAM_GEN getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4.
///
inline fapi2::ReturnCode get_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_GEN, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_GEN getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4.
///
inline fapi2::ReturnCode get_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_GEN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_TYPE getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM,
/// UDIMM, LRDIMM as specified by the JEDEC standard.
///
inline fapi2::ReturnCode get_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_TYPE, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_TYPE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM,
/// UDIMM, LRDIMM as specified by the JEDEC standard.
///
inline fapi2::ReturnCode get_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                       uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Hybrid Media. Decodes SPD Byte 3 (bits 6~4)
///
inline fapi2::ReturnCode get_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_HYBRID_MEMORY_TYPE, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Hybrid Media. Decodes SPD Byte 3 (bits 6~4)
///
inline fapi2::ReturnCode get_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_HYBRID_MEMORY_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_HYBRID getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Hybrid. Decodes SPD Byte 3 (bit 7)
///
inline fapi2::ReturnCode get_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_HYBRID, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_HYBRID getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Hybrid. Decodes SPD Byte 3 (bit 7)
///
inline fapi2::ReturnCode get_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_HYBRID, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per
/// die. For multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each
/// DRAM die in the stack.
///
inline fapi2::ReturnCode get_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_DENSITY, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per
/// die. For multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each
/// DRAM die in the stack.
///
inline fapi2::ReturnCode get_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_DENSITY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Number of DRAM bank address bits. Actual number of banks is 2^N, where
/// N is the number of bank address bits. Decodes SPD Byte 4 (bits 5~4).
///
inline fapi2::ReturnCode get_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_BANK_BITS, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Number of DRAM bank address bits. Actual number of banks is 2^N, where
/// N is the number of bank address bits. Decodes SPD Byte 4 (bits 5~4).
///
inline fapi2::ReturnCode get_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_BANK_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank
/// groups is 2^N, where N is the number of bank address bits. This value represents
/// the number of bank groups into which the memory array is divided.
///
inline fapi2::ReturnCode get_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank
/// groups is 2^N, where N is the number of bank address bits. This value represents
/// the number of bank groups into which the memory array is divided.
///
inline fapi2::ReturnCode get_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_COLUMN_BITS getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of
/// DRAM columns is 2^N, where N is the number of column address bits
///
inline fapi2::ReturnCode get_dram_columns_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_COLUMN_BITS, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_COLUMN_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_COLUMN_BITS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of
/// DRAM columns is 2^N, where N is the number of column address bits
///
inline fapi2::ReturnCode get_dram_columns_bits(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_COLUMN_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_COLUMN_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address
/// bits. Actual number of DRAM rows is 2^N, where N is the number of row address bits
///
inline fapi2::ReturnCode get_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_ROW_BITS, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address
/// bits. Actual number of DRAM rows is 2^N, where N is the number of row address bits
///
inline fapi2::ReturnCode get_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_ROW_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary
/// set of SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack =
/// 3DS
///
inline fapi2::ReturnCode get_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_PRIM_STACK_TYPE, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary
/// set of SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack =
/// 3DS
///
inline fapi2::ReturnCode get_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_PRIM_STACK_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_PPR getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
///
inline fapi2::ReturnCode get_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_PPR, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_PPR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
///
inline fapi2::ReturnCode get_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_PPR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Soft Post Package Repair. Used in various locations and is evaluated
/// in mss_eff_cnfg.
///
inline fapi2::ReturnCode get_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_SOFT_PPR, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Soft Post Package Repair. Used in various locations and is evaluated
/// in mss_eff_cnfg.
///
inline fapi2::ReturnCode get_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_SOFT_PPR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRCD getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum RAS to CAS Delay Time in nck (number of clock cyles). Decodes SPD byte 25
/// (7~0) and byte 112 (7~0). Each memory channel will have a value.
///
inline fapi2::ReturnCode get_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TRCD, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRP getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Row Precharge Delay Time in nck (number of clock cycles). Decodes SPD byte
/// 26 (bits 7~0) and byte 121 (bits 7~0). Each memory channel will have a value.
///
inline fapi2::ReturnCode get_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TRP, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRAS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Precharge Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 27 (bits 3~0) and byte 28 (7~0). Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing
///
inline fapi2::ReturnCode get_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TRAS, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRC getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Active/Refresh Delay in nck (number of clock cyles). Decodes SPD
/// byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120. Each memory channel will have
/// a value.
///
inline fapi2::ReturnCode get_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TRC, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRFC getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DDR4 Spec defined as Refresh Cycle Time (tRFC). SPD Spec refers it to the Minimum
/// Refresh Recovery Delay Time. In nck (number of clock cyles). Decodes SPD byte 31
/// (bits 15~8) and byte 30 (bits 7~0) for tRFC1. Decodes SPD byte 33 (bits 15~8) and
/// byte 32 (bits 7~0) for tRFC2. Decodes SPD byte 35 (bits 15~8) and byte 34 (bits
/// 7~0) for tRFC4. Selected tRFC value depends on MRW attribute that selects refresh
/// mode. For 3DS, The tRFC time to the same logical rank is defined as tRFC_slr and
/// is specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
///
inline fapi2::ReturnCode get_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TRFC, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TFAW getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 36 (bits 3~0) and byte 37 (bits 7~0). For 3DS, tFAW time to the same logical
/// rank is defined as tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices only) and specificed
/// as the value as for a monolithic DDR4 SDRAM equivalent density. Each memory channel
/// will have a value.
///
inline fapi2::ReturnCode get_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TFAW, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRRD_S getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, different bank group in nck (number of
/// clock cycles). Decodes SPD byte 38 (bits 7~0). For 3DS, The tRRD_S time to a different
/// bank group in the same logical rank is defined as tRRD_slr and is specificed as
/// the value as for a monolithic DDR4 SDRAM of equivalent density. Each memory channel
/// will have a value.
///
inline fapi2::ReturnCode get_dram_trrd_s(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TRRD_S, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TRRD_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRRD_L getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, same bank group in nck (number of clock
/// cycles). Decodes SPD byte 39 (bits 7~0). For 3DS, The tRRD_L time to the same bank
/// group in the same logical rank is defined as tRRD_L_slr and is specificed as the
/// value as for a monolithic DDR4 SDRAM of equivalent density. Each memory channel
/// will have a value.
///
inline fapi2::ReturnCode get_dram_trrd_l(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TRRD_L, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TRRD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRRD_DLR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time (different logical ranks) in nck (number
/// of clock cycles). For 3DS, The tRRD_S time to a different logical rank is defined
/// as tRRD_dlr. Each memory channel will have a value.
///
inline fapi2::ReturnCode get_dram_trrd_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TRRD_DLR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TRRD_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TCCD_L getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS to CAS Delay Time, same bank group in nck (number of clock cycles).
/// Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0). This is for DDR4 MRS6. Each
/// memory channel will have a value.
///
inline fapi2::ReturnCode get_dram_tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TCCD_L, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TWR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write Recovery Time. Decodes SPD byte 41 (bits 3~0) and byte 42 (bits 7~0).
/// Each memory channel will have a value.
///
inline fapi2::ReturnCode get_dram_twr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TWR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TWR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TWTR_S getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, different bank group in nck (number of clock cycles).
/// Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0). Each memory channel will have
/// a value.
///
inline fapi2::ReturnCode get_dram_twtr_s(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TWTR_S, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TWTR_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TWTR_L getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, same bank group in nck (number of clock cycles). Decodes
/// byte 43 (7~4) and byte 45 (bits 7~0). Each memory channel will have a value.
///
inline fapi2::ReturnCode get_dram_twtr_l(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TWTR_L, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TWTR_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TMAW getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Window in nck (number of clock cycles). Decodes SPD byte 7 (bits
/// 5~4). Depends on tREFI multiplier. Each memory channel will have a value.
///
inline fapi2::ReturnCode get_dram_tmaw(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TMAW, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TMAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits),
/// X8 (8 bits), X16 (16 bits), X32 (32 bits).
///
inline fapi2::ReturnCode get_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_WIDTH, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits),
/// X8 (8 bits), X16 (16 bits), X32 (32 bits).
///
inline fapi2::ReturnCode get_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_WIDTH, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Total number of ranks in each DIMM. For monolithic and multi-load stack
/// modules (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD
/// Byte 12 bits 5~3). For single load stack (3DS) modules this value represents the
/// number of logical ranks per DIMM. Logical rank refers the individually addressable
/// die in a 3DS stack and has no meaning for monolithic or multi-load stacked SDRAMs.
///
inline fapi2::ReturnCode get_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_NUM_RANKS_PER_DIMM, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Total number of ranks in each DIMM. For monolithic and multi-load stack
/// modules (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD
/// Byte 12 bits 5~3). For single load stack (3DS) modules this value represents the
/// number of logical ranks per DIMM. Logical rank refers the individually addressable
/// die in a 3DS stack and has no meaning for monolithic or multi-load stacked SDRAMs.
///
inline fapi2::ReturnCode get_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_NUM_RANKS_PER_DIMM, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_REGISTER_TYPE getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Register Type Decodes SPD Byte 131
///
inline fapi2::ReturnCode get_register_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_REGISTER_TYPE, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_REGISTER_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_REGISTER_TYPE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Register Type Decodes SPD Byte 131
///
inline fapi2::ReturnCode get_register_type(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_REGISTER_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_REGISTER_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_MFG_ID getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] DRAM Manufacturer ID Code Decodes SPD Byte 350 and 351
///
inline fapi2::ReturnCode get_dram_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_MFG_ID, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_MFG_ID getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] DRAM Manufacturer ID Code Decodes SPD Byte 350 and 351
///
inline fapi2::ReturnCode get_dram_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&o_array)[2])
{
    uint16_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_MFG_ID, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_RCD_MFG_ID getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Register Manufacturer ID Code Decodes SPD Byte 133 and 134
///
inline fapi2::ReturnCode get_rcd_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_RCD_MFG_ID, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_RCD_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_RCD_MFG_ID getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Register Manufacturer ID Code Decodes SPD Byte 133 and 134
///
inline fapi2::ReturnCode get_rcd_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                        uint16_t (&o_array)[2])
{
    uint16_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_RCD_MFG_ID, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_RCD_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_REGISTER_REV getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Register Revision Number Decodes SPD Byte 135
///
inline fapi2::ReturnCode get_register_rev(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_REGISTER_REV, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_REGISTER_REV: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_REGISTER_REV getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Register Revision Number Decodes SPD Byte 135
///
inline fapi2::ReturnCode get_register_rev(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_REGISTER_REV, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_REGISTER_REV: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_PACKAGE_RANK_MAP getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM][DQ_NIBBLES] Package Rank Map Decodes SPD Byte 60 - 77 (Bits 7~6)
///
inline fapi2::ReturnCode get_package_rank_map(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&o_array)[20])
{
    uint8_t l_value[2][20] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_PACKAGE_RANK_MAP, l_port, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 20);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_PACKAGE_RANK_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_PACKAGE_RANK_MAP getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM][DQ_NIBBLES] Package Rank Map Decodes SPD Byte 60 - 77 (Bits 7~6)
///
inline fapi2::ReturnCode get_package_rank_map(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2][20])
{
    uint8_t l_value[2][20] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_PACKAGE_RANK_MAP, i_target, l_value) );
    memcpy(o_array, &l_value, 40);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_PACKAGE_RANK_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_NIBBLE_MAP getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM][DQ_NIBBLES] Nibble Map Decodes SPD Byte 60 - 77 (Bits 5~0) for DDR4
///
inline fapi2::ReturnCode get_nibble_map(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t (&o_array)[20])
{
    uint8_t l_value[2][20] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_NIBBLE_MAP, l_port, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 20);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_NIBBLE_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_NIBBLE_MAP getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM][DQ_NIBBLES] Nibble Map Decodes SPD Byte 60 - 77 (Bits 5~0) for DDR4
///
inline fapi2::ReturnCode get_nibble_map(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                        uint8_t (&o_array)[2][20])
{
    uint8_t l_value[2][20] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_NIBBLE_MAP, i_target, l_value) );
    memcpy(o_array, &l_value, 40);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_NIBBLE_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_SIZE getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] DIMM Size, in GB Used in various locations
///
inline fapi2::ReturnCode get_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_SIZE, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_SIZE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint32_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] DIMM Size, in GB Used in various locations
///
inline fapi2::ReturnCode get_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                       uint32_t (&o_array)[2])
{
    uint32_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_SIZE, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_SPARE getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in mss_eff_cnfg.
/// Array indexes are [DIMM][RANK]
///
inline fapi2::ReturnCode get_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t (&o_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_SPARE, l_port, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DIMM_SPARE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DIMM_SPARE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in mss_eff_cnfg.
/// Array indexes are [DIMM][RANK]
///
inline fapi2::ReturnCode get_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                        uint8_t (&o_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DIMM_SPARE, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DIMM_SPARE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_CL getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value.
///
inline fapi2::ReturnCode get_dram_cl(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_CL, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Specifies the number of master ranks per DIMM. Represents the number
/// of physical ranks on a DIMM. From SPD spec JEDEC Standard No. 21-C: Page 4.1.2.L-4.
/// Byte 12 (Bits 5~3) Number of package ranks per DIMM. Package ranks per DIMM refers
/// to the collections of devices on the module sharing common chip select signals.
///
inline fapi2::ReturnCode get_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ARRAY[DIMM] Specifies the number of master ranks per DIMM. Represents the number
/// of physical ranks on a DIMM. From SPD spec JEDEC Standard No. 21-C: Page 4.1.2.L-4.
/// Byte 12 (Bits 5~3) Number of package ranks per DIMM. Package ranks per DIMM refers
/// to the collections of devices on the module sharing common chip select signals.
///
inline fapi2::ReturnCode get_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TREFI getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Average Refresh Interval (tREFI) in nck (number of clock cycles). This depends on
/// MRW attribute that selects fine refresh mode (x1, x2, x4). From DDR4 spec (79-4A).
/// For 3DS, the tREFI time to the same logical rank is defined as tRFC_slr1, tRFC_slr2,
/// or tRFC_slr4.
///
inline fapi2::ReturnCode get_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TREFI, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRTP getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. From the DDR4 spec (79-4A). Each memory channel
/// will have a value.
///
inline fapi2::ReturnCode get_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TRTP, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_DRAM_TRFC_DLR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Refresh Recovery Delay Time (different logical ranks) in nck (number of
/// clock cyles). Selected tRFC value (tRFC_dlr1, tRFC_dlr2, or tRFC_dlr4) depends on
/// MRW attribute that selects fine refresh mode (x1, x2, x4). For 3DS, The tRFC time
/// to different logical ranks are defined as tRFC_dlr
///
inline fapi2::ReturnCode get_dram_trfc_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_DRAM_TRFC_DLR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_DRAM_TRFC_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_FREQ getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Frequency of this memory channel in MT/s (Mega Transfers per second)
///
inline fapi2::ReturnCode get_freq(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_FREQ, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_FREQ: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_EFF_VOLT_VDDR getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Voltage, each voltage rail would need to have a value.
///
inline fapi2::ReturnCode get_volt_vddr(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target, uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_VOLT_VDDR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_VOLT_VDDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_VOLT_VPP getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM VPP Voltage, each voltage rail would need to have a value.
///
inline fapi2::ReturnCode get_volt_vpp(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target, uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_VOLT_VPP, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_VOLT_VPP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_SI_SIGNATURE_HASH getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hash Signature for SI settings from SPD. The hash signature is 32bits for 256 bytes
/// of data.
///
inline fapi2::ReturnCode get_si_signature_hash(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_SIGNATURE_HASH, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_SIGNATURE_HASH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_CA getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for Command/Address in
/// tens of Ohms.
///
inline fapi2::ReturnCode get_si_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CA, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DIMM_RCD_IBT_CA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_CA getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for Command/Address in
/// tens of Ohms.
///
inline fapi2::ReturnCode get_si_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CA, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DIMM_RCD_IBT_CA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_CKE getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for Clock Enable in tens
/// of Ohms.
///
inline fapi2::ReturnCode get_si_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CKE, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DIMM_RCD_IBT_CKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_CKE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for Clock Enable in tens
/// of Ohms.
///
inline fapi2::ReturnCode get_si_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CKE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DIMM_RCD_IBT_CKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_CS getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for Chip Select in tens
/// of Ohms.
///
inline fapi2::ReturnCode get_si_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CS, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DIMM_RCD_IBT_CS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_CS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for Chip Select in tens
/// of Ohms.
///
inline fapi2::ReturnCode get_si_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_CS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DIMM_RCD_IBT_CS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_ODT getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for On Die Termination
/// in tens of Ohms.
///
inline fapi2::ReturnCode get_si_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_ODT, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DIMM_RCD_IBT_ODT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DIMM_RCD_IBT_ODT getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM] Register Clock Driver, Input Bus Termination for On Die Termination
/// in tens of Ohms.
///
inline fapi2::ReturnCode get_si_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2])
{
    uint8_t l_value[2] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DIMM_RCD_IBT_ODT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DIMM_RCD_IBT_ODT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM][RANK] DQ and DQS Drive Impedance.
///
inline fapi2::ReturnCode get_si_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&o_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS, l_port, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM][RANK] DQ and DQS Drive Impedance.
///
inline fapi2::ReturnCode get_si_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_PREAMBLE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of clocks used for read/write preamble. Calibration only uses 1 nCK preamble
/// (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble option. The value of "0" means
/// 1 nCK preamble, the value of "1" means 2 nCK preamble. Bit 3 for READ preamble,
/// and Bit 7 for WRITE preamble. E.g. 0b00010001 means 2 nCK preamble for both READ
/// and WRITE
///
inline fapi2::ReturnCode get_si_dram_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_PREAMBLE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DRAM_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_RTT_NOM getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM][RANK] DRAM side Nominal Termination Resistance in Ohms.
///
inline fapi2::ReturnCode get_si_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&o_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_RTT_NOM, l_port, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_RTT_NOM getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM][RANK] DRAM side Nominal Termination Resistance in Ohms.
///
inline fapi2::ReturnCode get_si_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_RTT_NOM, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_RTT_PARK getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM][RANK] DRAM side Park Termination Resistance in Ohms.
///
inline fapi2::ReturnCode get_si_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&o_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_RTT_PARK, l_port, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_RTT_PARK getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM][RANK] DRAM side Park Termination Resistance in Ohms.
///
inline fapi2::ReturnCode get_si_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_RTT_PARK, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_RTT_WR getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM][RANK] DRAM side Write Termination Resistance in Ohms.
///
inline fapi2::ReturnCode get_si_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t (&o_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_RTT_WR, l_port, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_DRAM_RTT_WR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM][RANK] DRAM side Write Termination Resistance in Ohms.
///
inline fapi2::ReturnCode get_si_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_DRAM_RTT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Equalization for Data and Data Strobe Lines.
///
inline fapi2::ReturnCode get_si_mc_drv_eq_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CLK, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Address, Bank Address, Bank Group and
/// Activate Lines in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_imp_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock Enable, ODT, Parity, and Reset
/// Lines in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CNTL, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_CSCID getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_imp_cscid(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_CSCID, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_IMP_CSCID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[PSTATE] Memory Controller side Drive Impedance Pull Down for Data and Data
/// Strobe Lines in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_imp_dq_dqs_pull_down(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[1] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[PSTATE] Memory Controller side Drive Impedance Pull Down for Data and Data
/// Strobe Lines in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_imp_dq_dqs_pull_down(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[1])
{
    uint8_t l_value[1] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN, i_target, l_value) );
    memcpy(o_array, &l_value, 1);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[PSTATE] Memory Controller side Drive Impedance Pull Up for Data and Data Strobe
/// Lines in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_imp_dq_dqs_pull_up(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[1] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[PSTATE] Memory Controller side Drive Impedance Pull Up for Data and Data Strobe
/// Lines in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_imp_dq_dqs_pull_up(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[1])
{
    uint8_t l_value[1] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP, i_target, l_value) );
    memcpy(o_array, &l_value, 1);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Slew Rate for Clock in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_slew_rate_clk(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Slew Rate for Address, Bank Address, Bank Group and
/// Activate Lines in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_slew_rate_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Slew Rate for Clock Enable, ODT, Parity, and Reset
/// Lines in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_slew_rate_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Slew Rate for Chip Select and Chip ID Lines in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_slew_rate_cscid(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[PSTATE] Memory Controller side Drive Slew Rate for Data and Data Strobe Lines
/// in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_slew_rate_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[1] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[PSTATE] Memory Controller side Drive Slew Rate for Data and Data Strobe Lines
/// in Ohms.
///
inline fapi2::ReturnCode get_si_mc_drv_slew_rate_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[1])
{
    uint8_t l_value[1] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 1);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Receiver Equalization for Data and Data Strobe Lines.
///
inline fapi2::ReturnCode get_si_mc_rcv_eq_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_RCV_IMP_ALERT_N getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Receiver Impedance. Alert_N line in Ohms.
///
inline fapi2::ReturnCode get_si_mc_rcv_imp_alert_n(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_RCV_IMP_ALERT_N, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_RCV_IMP_ALERT_N: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[PSTATE] Memory Controller side Receiver Impedance. Data and Data Strobe Lines
/// in Ohms.
///
inline fapi2::ReturnCode get_si_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[1] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[PSTATE] Memory Controller side Receiver Impedance. Data and Data Strobe Lines
/// in Ohms.
///
inline fapi2::ReturnCode get_si_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[1])
{
    uint8_t l_value[1] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 1);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_ODT_RD getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM][RANK] READ, On Die Termination triggering bitmap. Use bitmap to determine
/// which ODT to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1 ODT1][N/A][N/A]
///
inline fapi2::ReturnCode get_si_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t (&o_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_ODT_RD, l_port, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_ODT_RD getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM][RANK] READ, On Die Termination triggering bitmap. Use bitmap to determine
/// which ODT to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1 ODT1][N/A][N/A]
///
inline fapi2::ReturnCode get_si_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                       uint8_t (&o_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_ODT_RD, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_ODT_WR getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM][RANK] WRITE, On Die Termination triggering bitmap. Use bitmap to determine
/// which ODT to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1 ODT1][N/A][N/A]
///
inline fapi2::ReturnCode get_si_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t (&o_array)[4])
{
    uint8_t l_value[2][4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_ODT_WR, l_port, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_ODT_WR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Array[DIMM][RANK] WRITE, On Die Termination triggering bitmap. Use bitmap to determine
/// which ODT to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1 ODT1][N/A][N/A]
///
inline fapi2::ReturnCode get_si_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
                                       uint8_t (&o_array)[2][4])
{
    uint8_t l_value[2][4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_ODT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_VREF_DRAM_WR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Vref setting for DDR4. Bit encode is 01234567. Bit 0 is unused.
/// Bit 1 is the Range. Bits 2-7 is the Value. Refer to the VrefDQ Training Table in
/// JEDEC.
///
inline fapi2::ReturnCode get_si_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_VREF_DRAM_WR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_VREF_MC_RD getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage
/// of Vdd. Disable = 0, defined as no HW adjustment or Vdd/2 if possible.
///
inline fapi2::ReturnCode get_si_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_VREF_MC_RD, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_SI_WINDAGE_RD_CTR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] int16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Derived from calibration/characterization of read centering. Number of windage offset
/// in units of pico-seconds[ps]. Default is 0 for no windage adjustment. Specification
/// of the value in this file is 2's compliment hex
///
inline fapi2::ReturnCode get_si_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        int16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_SI_WINDAGE_RD_CTR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_SI_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_MRW_IS_PLANAR getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Indicates if the DIMM connected to this controller are in a planar configuration
///
inline fapi2::ReturnCode get_mem_mrw_is_planar(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_MRW_IS_PLANAR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_MRW_IS_PLANAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_MRW_POWER_CONTROL_REQUESTED getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory power control settings programmed during IPL Used by OCC when exiting idle
/// power-save mode
///
inline fapi2::ReturnCode get_mrw_power_control_requested(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_POWER_CONTROL_REQUESTED, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_POWER_CONTROL_REQUESTED: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


} // attr
} // mss

#endif
