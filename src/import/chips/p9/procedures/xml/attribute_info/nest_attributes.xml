<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
<!-- This is an automatically generated prolog.                             -->
<!--                                                                        -->
<!-- $Source: src/import/chips/p9/procedures/xml/attribute_info/nest_attributes.xml $ -->
<!--                                                                        -->
<!-- OpenPOWER HostBoot Project                                             -->
<!--                                                                        -->
<!-- Contributors Listed Below - COPYRIGHT 2015,2019                        -->
<!-- [+] International Business Machines Corp.                              -->
<!--                                                                        -->
<!--                                                                        -->
<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
<!-- you may not use this file except in compliance with the License.       -->
<!-- You may obtain a copy of the License at                                -->
<!--                                                                        -->
<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
<!--                                                                        -->
<!-- Unless required by applicable law or agreed to in writing, software    -->
<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
<!-- implied. See the License for the specific language governing           -->
<!-- permissions and limitations under the License.                         -->
<!--                                                                        -->
<!-- IBM_PROLOG_END_TAG                                                     -->
<!--nest_attributes.xml-->
<attributes>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_PB_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The frequency of a processor's nest mesh clock, in MHz.
    This is the same for all chips in the system.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <enum>
    1600 = 1600,
    1866 = 1866,
    2000 = 2000,
    2133 = 2133,
    2400 = 2400
  </enum>
  <platInit/>
  <writeable/>
  <mssAccessorName>freq_pb_mhz</mssAccessorName>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_MCA_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The frequency of the memory controller channel. In synchronous mode,
    this is equivalent to ATTR_FREQ_PB_MHZ. This may be independently set
    per pair of memory channels if operating in asynchronous mode,
    but this configuration is not anticipated. This clock drives the MCU queues,
    and all the associated logic that drives the inputs to the DMI and reads
    its outputs.
  </description>
  <valueType>uint32</valueType>
  <enum>
    2000 = 2000,
    2400 = 2400
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_O_MHZ</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    The frequency of a processor's Obus mesh clocks, in MHz.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
  <array>4</array>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_A_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The frequency of a processor's Abus, in MHz.
    This is the same for all chips in the system.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
  <writeable/><!-- only for sim tools -->
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_X_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The frequency of a processor's Xbus mesh clocks, in MHz.
    This is the same for all chips in the system.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_CORE_FLOOR_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The lowest frequency that a core can be set to in MHz.
    This is the same for all cores in the system.
    Provided by the MVPD #V and is calculated as the max of the
    Power Save frequencies.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_CORE_NOMINAL_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The nominal core frequency in MHz.
    This is the same for all cores in the system.
    Provided by the #V bucket of module VPD.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_CORE_CEILING_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The maximum core frequency in MHz.
    This is the same for all cores in the system.
    Provided by the #V bucket of module VPD and is calculated
    as the minimum of the turbo frequencies.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PM_SAFE_FREQUENCY_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Frequency (in MHz) to move to if the Power Management function fails.
    This is the same for all cores in the system.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PM_SAFE_VOLTAGE_MV</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Voltage (in mV) to move to if the Power Management function fails.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FREQ_PCIE_MHZ</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The frequency of a processor's PCI-e bus in MHz.
    This is the same for all PCI-e busses in the system.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
 </attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_DD1_SLOW_PCI_REF_CLOCK</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    MRW control to permit Normal (100 MHz) or Slow (94 MHz) operation
    of PCIE reference clock.  On Nimbus DD1 HW, Slow operation is required
    to achieve Gen4 operation.
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    NORMAL = 0x00,
    SLOW = 0x01
  </enum>
  <platInit/>
 </attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_ASYNC_SAFE_MODE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Set to force all fabric asynchronous boundary crossings into safe mode.
  </description>
  <valueType>uint8</valueType>
  <enum>
    PERFORMANCE_MODE = 0x0,
    SAFE_MODE = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_BUS_WIDTH</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP A bus width.
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    2_BYTE = 0x01,
    4_BYTE = 0x02
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_BUS_WIDTH</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP X bus width.
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    2_BYTE = 0x01,
    4_BYTE = 0x02
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_CORE_FLOOR_RATIO</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP core floor/nest frequency ratio
  </description>
  <valueType>uint8</valueType>
  <enum>
    RATIO_8_8 = 0x0,
    RATIO_7_8 = 0x1,
    RATIO_6_8 = 0x2,
    RATIO_5_8 = 0x3,
    RATIO_4_8 = 0x4,
    RATIO_2_8 = 0x5
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_CORE_CEILING_RATIO</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP core celing/nest frequency ratio
  </description>
  <valueType>uint8</valueType>
  <enum>
    RATIO_8_8 = 0x0,
    RATIO_7_8 = 0x1,
    RATIO_6_8 = 0x2,
    RATIO_5_8 = 0x3,
    RATIO_4_8 = 0x4,
    RATIO_2_8 = 0x5
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_PUMP_MODE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP Fabric broadcast scope configuration.
    CHIP_IS_NODE = MODE1 = default
    CHIP_IS_GROUP = MODE2
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    CHIP_IS_NODE = 0x01,
    CHIP_IS_GROUP = 0x02
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_CCSM_MODE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP topology configuration.
    0 = default = 1 or 2 hop topology (PHYP image spans system)
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    OFF = 0x0
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_OPTICS_CONFIG_MODE</id>
  <targetType>TARGET_TYPE_OBUS</targetType>
  <description>
    Per-link optics configuration
    0 = default = SMP
    1 = CAPI 2.0
    2 = NV 2.0
    3 = OPENCAPI
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    SMP = 0x0,
    CAPI = 0x1,
    NV = 0x2,
    OCAPI = 0x3
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_SMP_OPTICS_MODE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor SMP optics mode.
    0 = default = Optics_is_X_bus
    1 = Optics_is_A_bus
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    OPTICS_IS_X_BUS = 0x0,
    OPTICS_IS_A_BUS = 0x1
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_OPTICS_CONFIG_MODE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Per-link optics configuration
    0 = default = SMP
    1 = CAPI 2.0
    2 = NV 2.0
  </description>
  <valueType>uint8</valueType>
  <enum>
    SMP = 0x0,
    CAPI = 0x1,
    NV = 0x2
  </enum>
  <array>4</array>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_CAPI_MODE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor CAPI attachement protocol mode.
    0 = default = no: SMPA CAPI attachement
    1 = yes: SMPA CAPI attachement
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FABRIC_PRESENT_GROUPS</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Bit mask of group IDs which will be present in the fully configured
    CEC configuration.
      Bit 0 -> group 0 present
      Bit 1 -> group 1 present
      ...
      Bit 6 -> group 6 present
      Bit 7 -> group 7 present
  </description>
  <valueType>uint8</valueType>
  <platInit/>
  <mrwHide/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_SYSTEM_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Logical fabric system ID associated with this chip.
    Provided by the MRW.
  </description>
  <valueType>uint32</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FABRIC_ADDR_EXTENSION_GROUP_ID</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Address extension enable value for RA 15:18
  </description>
  <valueType>uint8</valueType>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_FABRIC_ADDR_EXTENSION_CHIP_ID</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Address extension enable value for RA 19:21
  </description>
  <valueType>uint8</valueType>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_GROUP_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Logical fabric group ID associated with this chip.
    Directly drives programming of pervasive group ID registers (PIR).
    Compared with ATTR_PROC_EFF_FABRIC_GROUP_ID to configure FBC XOR masking.
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EFF_FABRIC_GROUP_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Effective fabric group ID associated with this chip.
    Directly drives programming of chip memory map layout.
    Compared with ATTR_PROC_FABRIC_GROUP_ID to configure FBC XOR masking.
  </description>
  <valueType>uint8</valueType>
  <platInit/>
  <mrwHide/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_CHIP_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Logical fabric chip ID associated with this chip.
    Directly drives programming of pervasive chip ID registers (PIR).
    Compared with ATTR_PROC_EFF_FABRIC_CHIP_ID to configure FBC XOR masking.
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EFF_FABRIC_CHIP_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Effective fabric chip ID associated with this chip.
    Directly drives programming of chip memory map layout.
    Compared with ATTR_PROC_FABRIC_CHIP_ID to configure FBC XOR masking.
  </description>
  <valueType>uint8</valueType>
  <platInit/>
  <mrwHide/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_SYSTEM_MASTER_CHIP</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Indicates if the given chip should serve as the fabric system master.
  </description>
  <valueType>uint8</valueType>
  <enum>
    FALSE = 0x0,
    TRUE = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_GROUP_MASTER_CHIP</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Indicates if the given chip should serve as the fabric group master.
  </description>
  <valueType>uint8</valueType>
  <enum>
    FALSE = 0x0,
    TRUE = 0x1
  </enum>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_LINK_ACTIVE</id>
  <targetType>TARGET_TYPE_XBUS,TARGET_TYPE_OBUS</targetType>
  <description>
    Indicates if the endpoint target is actively being used as a fabric link
  </description>
  <valueType>uint8</valueType>
  <enum>
    FALSE = 0x0,
    TRUE = 0x1
  </enum>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_LINK_TRAIN</id>
  <targetType>TARGET_TYPE_XBUS,TARGET_TYPE_OBUS</targetType>
  <description>
    Indicates which sublinks should be initialized/trained
  </description>
  <valueType>uint8</valueType>
  <enum>
    BOTH = 0x0,
    EVEN_ONLY = 0x1,
    ODD_ONLY = 0x2,
    NONE = 0x3
  </enum>
  <initToZero/>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    For each fabric X link on this chip, specifies whether or not the chip at the
    receiving end of the link is present and configured
  </description>
  <valueType>uint8</valueType>
  <array>7</array>
  <enum>
    FALSE = 0x0,
    TRUE = 0x1,
    EVEN_ONLY = 0x2,
    ODD_ONLY = 0x3
  </enum>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_LINKS_CNFG</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Contains the total number of active X links on this chip
  </description>
  <valueType>uint8</valueType>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    For each fabric A link on this chip, specifies whether or not the chip at the
    receiving end of the link is present and configured
  </description>
  <valueType>uint8</valueType>
  <array>4</array>
  <enum>
    FALSE = 0x0,
    TRUE = 0x1,
    EVEN_ONLY = 0x2,
    ODD_ONLY = 0x3
  </enum>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_LINKS_CNFG</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Contains the total number of active A links on this chip
  </description>
  <valueType>uint8</valueType>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    For each fabric X link on this chip, specifies the fabric ID of the chip at the
    receiving end of the link.  Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG index is true.
  </description>
  <valueType>uint8</valueType>
  <array>7</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    For each fabric X link on this chip, specifies the link ID of the chip at the
    receiving end of the link.  Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG index is true.
  </description>
  <valueType>uint8</valueType>
  <array>7</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    For each fabric A link on this chip, specifies the fabric ID of the chip at the
    receiving end of the link.  Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG index is true.
  </description>
  <valueType>uint8</valueType>
  <array>4</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    For each fabric A link on this chip, specifies the link ID of the chip at the
    receiving end of the link.  Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG index is true.
  </description>
  <valueType>uint8</valueType>
  <array>4</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_AGGREGATE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Indicates if X links on this chip should be configured in aggregate mode.
  </description>
  <valueType>uint8</valueType>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_ADDR_DIS</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Indicates if link should be used to carry data only (in aggregate configurations).
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG
    index is true.
  </description>
  <valueType>uint8</valueType>
  <array>7</array>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_X_LINK_DELAY</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Average of local/remote end link delay counter values.
    Used to designate coherent link in aggregate configurations.
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG
    index is true.
  </description>
  <valueType>uint32</valueType>
  <array>7</array>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_AGGREGATE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Indicates if A links on this chip should be configured in aggregate mode.
  </description>
  <valueType>uint8</valueType>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_ADDR_DIS</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Indicates if link should be used to carry data only (in aggregate configurations).
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG
    index is true.
  </description>
  <valueType>uint8</valueType>
  <array>4</array>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_FABRIC_A_LINK_DELAY</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description>
    Average of local/remote end link delay counter values.
    Used to designate coherent link in aggregate configurations.
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG
    index is true.
  </description>
  <valueType>uint32</valueType>
  <array>4</array>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_GB_PERCENTAGE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Guardband percentage to apply to baseline epsilon calculations
    Set by p9_fbc_eff_config.
  </description>
  <valueType>int8</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_TABLE_TYPE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Processor epsilon table type.
    Used to calculate the processor nest epsilon register values.
    Provided by the MRW.
  </description>
  <valueType>uint8</valueType>
  <enum>
    EPS_TYPE_LE = 0x01,
    EPS_TYPE_HE = 0x02,
    EPS_TYPE_HE_F8 = 0x03
  </enum>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_READ_CYCLES_T0</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Calculated read tier0 epsilon protection count.
  </description>
  <valueType>uint32</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_READ_CYCLES_T1</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Calculated read tier1 epsilon protection count.
  </description>
  <valueType>uint32</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_READ_CYCLES_T2</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Calculated read tier2 epsilon protection count.
  </description>
  <valueType>uint32</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_WRITE_CYCLES_T1</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Calculated write tier1 epsilon protection count.
  </description>
  <valueType>uint32</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_EPS_WRITE_CYCLES_T2</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Calculated write tier2 epsilon protection count.
  </description>
  <valueType>uint32</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_DMI_REFCLOCK_SWIZZLE</id>
  <targetType>TARGET_TYPE_DMI</targetType>
  <description>
      Define DMI Ref clock/Swizzle for Centaur.
      Mapper from DMI unit id -> ROOT CNTL 6 refclk drive enable bit
      consumer: p9_cen_ref_clk_enable
      </description>
  <valueType>uint8</valueType>
  <persistRuntime/>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_OMI_REFCLOCK_SWIZZLE</id>
  <targetType>TARGET_TYPE_OMI</targetType>
  <description>
      Define OMI Ref clock/Swizzle for OCMB/Explorer..
      Mapper from OMI unit id -> ROOT CNTL 7 refclk drive enable bit
      consumer: p9a_ocmb_enable
      </description>
  <valueType>uint8</valueType>
  <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_SYSTEM_IPL_PHASE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>Define context for current phase of system IPL.
  </description>
  <valueType>uint8</valueType>
  <enum>HB_IPL = 0x1,HB_RUNTIME = 0x2,CACHE_CONTAINED = 0x4,CHIP_CONTAINED = 0x8,NONHB_IPL = 0x10</enum>
  <writeable/>
  <platInit/>
  <mrwHide/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_IS_MPIPL</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Indicates if current IPL is memory-preserving
  </description>
  <valueType>uint8</valueType>
  <enum>
    FALSE = 0x0,
    TRUE = 0x1
  </enum>
  <platInit/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>XSCOM BAR base address offset
    creator: platform
    consumer: p9_sbe_scominit
    firmware notes:
      Defines 16GB range (size implied) mapped for XSCOM usage
      Attribute holds offset (relative to chip MMIO origin) to program into
      chip address range field of BAR -- RA bits 22:29
      (excludes system/memory select/group/chip fields)
  </description>
  <valueType>uint64</valueType>
  <platInit/>
  <mrwHide/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>LPC BAR base address offset
    creator: platform
    consumer: p9_sbe_scominit
    firmware notes:
      Defines 4GB range (size implied) mapped for LPC usage
      Attribute holds offset (relative to chip MMIO origin) to program into
      chip address range field of BAR -- RA bits 22:31
      (excludes system/memory select/group/chip fields)
  </description>
  <valueType>uint64</valueType>
  <platInit/>
  <mrwHide/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_MAX_INTERLEAVE_GROUP_SIZE</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    The physical capacity of each msel region is 4_TB without extended addressing.
    This attribute defines the maximum addressable space to be used within each msel,
    which may be lower than the physical capacity.
  </description>
  <valueType>uint64</valueType>
  <writeable/>
  <persistRuntime/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_MEM_MIRROR_PLACEMENT_POLICY</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>Define placement policy/scheme for non-mirrored/mirrored memory
               layout
               NORMAL = non-mirrored start: 0, mirrored start: 1024TB
               FLIPPED = mirrored start: 0, non-mirrored start: 512TB
               Set by platform.
               Used by mss_eff_grouping.
  </description>
  <valueType>uint8</valueType>
  <enum>
    NORMAL    = 0x0,
    FLIPPED   = 0x1
  </enum>
  <platInit/>
  <mrwHide/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_MEM_BASES</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The address where each memory group starts in the non-mirrored
                memory groups stack.  This address is determined by the memory
                grouping process based on the sizes of the memory groups formed
                in each processor.
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <array>8</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_MEM_SIZES</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The memory size of each non-mirrored memory group in the
                non-mirrored memory groups stack.  This size is determined by
                the memory grouping process based on the amount of memory
                behind the ports that are grouped together.
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <array>8</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_MIRROR_BASES</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The address where each memory group starts in the mirrored
                memory groups stack.  This address is determined by
                the memory grouping process based on the sizes of the memory
                groups formed in each processor.
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <array>8</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_MIRROR_SIZES</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The memory size of each memory group in the mirrored memory
                groups stack.  This size is determined by the memory grouping
                process based on the amount of memory behind the ports that are
                grouped together.
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <array>8</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
    <id>ATTR_MSS_INTERLEAVE_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
      Used in the setting of groups.  It is a bit vector.  If the value
      BITWISE_AND  0x01 = 0x01 then groups of 1 are enabled,
      if the value BITWISE_AND  0x02 = 0x02, then groups of 2 are possible,
      if the value BITWISE_AND  0x04 = 0x04, then group of 3 are possible,
      if the value BITWISE_AND  0x08 = 0x08, then groups of 4 are possible,
      if the value BITWISE_AND 0x20 = 0x20, then groups of 6 are possible,
      if the value BITWISE_AND 0x80 = 0x80, then groups of 8 are possible.
      If no groups can formed according to this input, then an error will
      be thrown.
      Provided by the MRW
    </description>
    <valueType>uint8</valueType>
    <platInit/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
    <id>ATTR_MSS_INTERLEAVE_GRANULARITY</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
      Determines the stride covered by each granule in an interleaving
      group.  The default stride -- 128B -- is the only value intended for
      production FW use.  All other combinations are for experimental
      performance evaluation.

      Regardless of this attribute value, groups of size 1, 3, and 6
      will be forced to 128B stride based on the logic capabilities.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
      128_B = 0x00,
      256_B = 0x01,
      512_B = 0x02,
      1_KB  = 0x03,
      2_KB  = 0x04,
      4_KB  = 0x05,
      8_KB  = 0x06,
      16_KB = 0x07,
      32_KB = 0x08
    </enum>
    <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
    <id>ATTR_MSS_MEM_MC_IN_GROUP</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
      An 8 bit vector that would be a designation of which MC (Nimbus MCA or
      Cumulus MI) are involved in the group.
      So the bits would represent
                  Nimbus   Cumulus
        Bit 0     MCA0     MI0
        Bit 1     MCA1     MI1
        .....
        Bit 7     MCA7     MI7
      Set by p9_mss_eff_grouping
    </description>
    <valueType>uint8</valueType>
    <writeable/>
    <array>8</array>
    <persistRuntime/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
    <id>ATTR_MSS_MCS_GROUP_32</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
       creator:- mss_eff_grouping
       consumer:- mss_setup_bars
       Data Structure from eff grouping to setup bars to help determine
       different groups
       Non-Mirroring array[0-7]  [0.20]:  0-- Port size; 1-- No of ports in group; 2-- Total group size of non-mirroring;
                                          3-- Base address; 4-11-- PortID number in group;
                                         12-- Alt Memory valid(0); 13-- Alt Memory valid (1);
                                         14-- Alt Group size (0); 15-- Alt Group size(1);
                                         16-- Alt Base address (0); 17-- Alt Base address (1);
                                         18-- SMF Memory Valid
                                         19-- SMF Group Size (size[22:35] in lower bits)
                                         20-- SMF Base Address (addr[22:35] in lower bits)


       Mirroring     array[8-15] [0:20]:  0-- Port size; 1-- No of ports in group; 2-- Total group size of mirroring;
                                          3-- Base address; 4-11-- PortID number;
                                         12-- Alt Memory valid(0); 13-- Alt Memory valid (1);
                                         14-- Alt Group size (0); 15-- Alt Group size(1);
                                         16-- Alt Base address (0); 17-- Alt Base address (1);
                                         18-- SMF Memory Valid
                                         19-- SMF Group Size (size[22:35] in lower bits)
                                         20-- SMF Base Address (addr[22:35] in lower bits)
       Measured in GB
     </description>
    <valueType>uint32</valueType>
    <array>16,21</array>
    <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
    <id>ATTR_MSS_MEM_IPL_COMPLETE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
       Creator:- mss_setup_bars
       A numerical number indicating if the memory procedures are complete.
       written by mss_setup_bars when the bars are now functional in the
       processor.
    </description>
    <valueType>uint8</valueType>
    <writeable/>
    <persistRuntime/>
    <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
    <id>ATTR_MRW_HW_MIRRORING_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
       REQUIRED/TRUE: HW mirroring is enabled, and all channels are required
                      to be part of a mirrored group.
       REQUESTED : HW mirroring is enabled.  Mirroring will be configured for
                   groups which support it, but not all channels are required
                   to be mirrored.
       FALSE : HW mirroring is disabled.
       Provided by the MRW.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>FALSE = 0, TRUE = 1, REQUESTED = 2</enum>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_NHTM_BAR_BASE_ADDR</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The base address where the NHTM traces start.  They are
                calculated based on the NHTM trace size requested by user.
                This address in memory will be the location where NHTM0/1
                traces are output.
                Set by p9_mss_eff_grouping.
                Used by p9_setup_bars and p9_htm_setup.
  </description>
  <valueType>uint64</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_NHTM_BAR_SIZE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The amount of memory a user can reserve to store NHTM traces.
                This amount will be used to store both NHTM0 and NHTM1 traces.
                Used by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <enum>
    256_GB = 0x0000004000000000,
    128_GB = 0x0000002000000000,
     64_GB = 0x0000001000000000,
     32_GB = 0x0000000800000000,
     16_GB = 0x0000000400000000,
      8_GB = 0x0000000200000000,
      4_GB = 0x0000000100000000,
      2_GB = 0x0000000080000000,
      1_GB = 0x0000000040000000,
    512_MB = 0x0000000020000000,
    256_MB = 0x0000000010000000,
    128_MB = 0x0000000008000000,
     64_MB = 0x0000000004000000,
     32_MB = 0x0000000002000000,
     16_MB = 0x0000000001000000,
      ZERO = 0x0000000000000000
  </enum>
  <initToZero/>
  <writeable/>
</attribute>

<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_CHTM_BAR_BASE_ADDR</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The base addresses where the CHTM traces start.  They are
                calculated based on the CHTM trace sizes requested by users.
                There are 24 different CHTM regions, thus 24 different sizes.
                Each region is to store HTM trace for a core.
                Set by p9_mss_eff_grouping.
                Used by p9_setup_bars.
  </description>
  <valueType>uint64</valueType>
  <array>24</array>
  <writeable/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_CHTM_BAR_SIZES</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The amount of memory a user can reserve to store CHTM traces.
                There are 24 cores, thus 24 different sizes.
                Used by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <enum>
    256_GB = 0x0000004000000000,
    128_GB = 0x0000002000000000,
     64_GB = 0x0000001000000000,
     32_GB = 0x0000000800000000,
     16_GB = 0x0000000400000000,
      8_GB = 0x0000000200000000,
      4_GB = 0x0000000100000000,
      2_GB = 0x0000000080000000,
      1_GB = 0x0000000040000000,
    512_MB = 0x0000000020000000,
    256_MB = 0x0000000010000000,
    128_MB = 0x0000000008000000,
     64_MB = 0x0000000004000000,
     32_MB = 0x0000000002000000,
     16_MB = 0x0000000001000000,
      ZERO = 0x0000000000000000
  </enum>
  <array>24</array>
  <initToZero/>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_SMF_BAR_BASE_ADDR</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The base address where the SMF bar starts.It is
                calculated based on the SMF size requested by users.
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_SMF_BAR_SIZE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The total amount of memory a user has requested to reserve for
                secure memory functions. Minimum requirement of 256MB.
                Used by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <enum>
    256_GB = 0x0000004000000000,
    128_GB = 0x0000002000000000,
     64_GB = 0x0000001000000000,
     32_GB = 0x0000000800000000,
     16_GB = 0x0000000400000000,
      8_GB = 0x0000000200000000,
      4_GB = 0x0000000100000000,
      2_GB = 0x0000000080000000,
      1_GB = 0x0000000040000000,
    512_MB = 0x0000000020000000,
    256_MB = 0x0000000010000000,
      ZERO = 0x0000000000000000
  </enum>
  <initToZero/>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_SMF_CONFIG</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description> Controls the enabling and disabling of smf.
                Used by unit initfiles, p9_mss_eff_grouping.
  </description>
  <valueType>uint8</valueType>
  <enum>
    DISABLED = 0x00,
    ENABLED = 0x01
  </enum>
  <platInit/>
  <initToZero/>
  <mrwHide/><!-- Temporary until the function is actually ready -->
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_SMF_ENABLED</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description> True if smf config is enabled and smf is supported in the
                chip ec level. Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint8</valueType>
  <enum>
    FALSE = 0x00,
    TRUE = 0x01
  </enum>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_OCC_SANDBOX_BASE_ADDR</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The base address where the OCC sandbox starts.  It is
                calculated based on the OCC sandbox size requested by users.
                Set by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <writeable/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_OCC_SANDBOX_SIZE</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The amount of memory a user can reserve to store OCC sandbox
                functions.
                Used by p9_mss_eff_grouping.
  </description>
  <valueType>uint64</valueType>
  <enum>
    256_GB = 0x0000004000000000,
    128_GB = 0x0000002000000000,
     64_GB = 0x0000001000000000,
     32_GB = 0x0000000800000000,
     16_GB = 0x0000000400000000,
      8_GB = 0x0000000200000000,
      4_GB = 0x0000000100000000,
      2_GB = 0x0000000080000000,
      1_GB = 0x0000000040000000,
    512_MB = 0x0000000020000000,
    256_MB = 0x0000000010000000,
    128_MB = 0x0000000008000000,
     64_MB = 0x0000000004000000,
     32_MB = 0x0000000002000000,
     16_MB = 0x0000000001000000,
      ZERO = 0x0000000000000000
  </enum>
  <initToZero/>
  <writeable/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_MEM_BASES_ACK</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The actual non-mirrored base addresses of the groups formed
                by the memory grouping process.  These values correspond to
                the BAR programming and would be acknowleged on the fabric.
                Set by p9_mss_eff_grouping.
                Used by p9_setup_bars.
  </description>
  <valueType>uint64</valueType>
  <array>8</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->
<attribute>
  <id>ATTR_PROC_MEM_SIZES_ACK</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The actual non-mirrored memory sizes of the groups formed
                by the memory grouping process.  These values correspond to
                the BAR programming.
                Set by p9_mss_eff_grouping.
                Used by p9_setup_bars.
  </description>
  <valueType>uint64</valueType>
  <array>8</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_MIRROR_BASES_ACK</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The actual mirrored base addresses of the groups formed
                by the memory grouping process.  These values correspond to
                the BAR programming and would be acknowleged on the fabric.
                Set by p9_mss_eff_grouping.
                Used by p9_setup_bars.
  </description>
  <valueType>uint64</valueType>
  <array>8</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_PROC_MIRROR_SIZES_ACK</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The actual mirrored memory sizes of the groups formed
                by the memory grouping process.  These values correspond to
                the BAR programming.
                Set by p9_mss_eff_grouping.
                Used by p9_setup_bars.
  </description>
  <valueType>uint64</valueType>
  <array>8</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ********************************************************************* -->
<attribute>
  <id>ATTR_HTM_QUEUES</id>
  <targetType>TARGET_TYPE_PROC_CHIP</targetType>
  <description> The number of HTM queues to be reserved for each port in order
                to improve HTM trace performance.
                This number is calculated in memory grouping process when the
                HTM trace spaces are determined.
                Set by p9_mss_eff_grouping.
                Used by p9_htm_setup.
  </description>
  <valueType>uint8</valueType>
  <array>8</array>
  <writeable/>
  <initToZero/>
</attribute>
<!-- ******************************************************************** -->
<attribute>
  <id>ATTR_ENABLE_MEM_EARLY_DATA_SCOM</id>
  <targetType>TARGET_TYPE_SYSTEM</targetType>
  <description>
    Enable early data from Memory. This also enable cp_me from L3.
  </description>
  <valueType>uint8</valueType>
  <enum>
    OFF = 0x0,
    ON = 0x1
  </enum>
  <platInit/>
  <initToZero/>
</attribute>
<!-- ********************************************************************** -->

</attributes>
