/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/import/chips/p9/procedures/hwp/memory/lib/mss_attribute_accessors.H $ */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2016,2019                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
// mss_attribute_accessors.H
#ifndef MSS_ATTR_ACCESS_H_
#define MSS_ATTR_ACCESS_H_

#include <fapi2.H>
#include <lib/mss_utils.H>
#include <lib/mss_attribute_accessors_manual.H>



namespace mss
{
///
/// @brief ATTR_MSS_VOLT_VDDR getter
/// @param[in] const ref to the TARGET_TYPE_MCBIST
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Voltage, each voltage rail would need to have a value. Computed in mss_volt
/// C code - in millivolts creator: mss_volt consumer: mss_eff_cnfg, others firmware
/// notes:
/// none
///
inline fapi2::ReturnCode volt_vddr(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VOLT_VDDR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VOLT_VDDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_FREQ_OVERRIDE getter
/// @param[in] const ref to the TARGET_TYPE_MCBIST
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  FOR LAB USE ONLY: Frequency override of this memory channel in MT/s comprising
/// of up to three DIMMs. Set by config file or an attribute writing program.
/// Consumed by mss_freq. The default of AUTO means mss_freq will find the best
/// frequencies given the DIMMs plugged in and other rules. Otherwise, this is the
/// system
/// frequency.
///
inline fapi2::ReturnCode freq_override(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_FREQ_OVERRIDE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_FREQ_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_FREQ getter
/// @param[in] const ref to the TARGET_TYPE_MCBIST
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Frequency of this memory channel in MT/s (Mega Transfers per second), comprising
/// of three DIMMs. Computed in mss_freq creator: mss_freq consumer: mss_eff_cnfg,
/// others firmware notes:
/// none
///
inline fapi2::ReturnCode freq(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_FREQ, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_FREQ: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SIZE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Size, in GB Used in various locations and is computed in
/// mss_eff_cnfg.
///
inline fapi2::ReturnCode eff_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SIZE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SIZE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Size, in GB Used in various locations and is computed in
/// mss_eff_cnfg.
///
inline fapi2::ReturnCode eff_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SIZE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SIZE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Size, in GB Used in various locations and is computed in
/// mss_eff_cnfg.
///
inline fapi2::ReturnCode eff_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SIZE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value. creator: mss_freq consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cl(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value. creator: mss_freq consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value. creator: mss_freq consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cl(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_AL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additive Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_al(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_AL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_AL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_AL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additive Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_al(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_AL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_AL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_AL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additive Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_al(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_AL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_AL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CWL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CWL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CWL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CWL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CWL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CWL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Burst Type. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rbt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RBT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Burst Type. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rbt(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RBT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Burst Type. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rbt(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RBT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Test Mode. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Test Mode. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Test Mode. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_RESET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Reset. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_reset(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_RESET, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_RESET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_RESET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Reset. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_reset(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_RESET, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_RESET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_RESET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Reset. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_reset(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_RESET, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_RESET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Enable. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_ENABLE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Enable. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_ENABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Enable. Used in various locations and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_LVL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Level Enable. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_wr_lvl_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_LVL_ENABLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_LVL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_LVL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Level Enable. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_wr_lvl_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_LVL_ENABLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_LVL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_LVL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Level Enable. Used in various locations and is computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_wr_lvl_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_LVL_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_LVL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_OUTPUT_BUFFER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Qoff. Enables or disables DRAM output. Used in various locations and is
/// computed in mss_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_output_buffer(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_OUTPUT_BUFFER, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_OUTPUT_BUFFER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_OUTPUT_BUFFER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Qoff. Enables or disables DRAM output. Used in various locations and is
/// computed in mss_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_output_buffer(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_OUTPUT_BUFFER, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_OUTPUT_BUFFER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_OUTPUT_BUFFER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Qoff. Enables or disables DRAM output. Used in various locations and is
/// computed in mss_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_output_buffer(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_OUTPUT_BUFFER, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_OUTPUT_BUFFER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Mode. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Mode. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Mode. Used in various locations and is computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC00: Global Features Control Word.For normal operation, output inversion is
/// always enabled. For DIMM vendor test purpose, output inversion can be disabled.
/// When disabled, register tPDM is not guaranteed to be met. NOTE: Default value -
/// 0x00. Values Range from 0-8. 00 - Normal Operation; 01 - Output Inversion
/// Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs
/// disabled; So on. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC00, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC00: Global Features Control Word.For normal operation, output inversion is
/// always enabled. For DIMM vendor test purpose, output inversion can be disabled.
/// When disabled, register tPDM is not guaranteed to be met. NOTE: Default value -
/// 0x00. Values Range from 0-8. 00 - Normal Operation; 01 - Output Inversion
/// Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs
/// disabled; So on. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc00(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC00, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC00: Global Features Control Word.For normal operation, output inversion is
/// always enabled. For DIMM vendor test purpose, output inversion can be disabled.
/// When disabled, register tPDM is not guaranteed to be met. NOTE: Default value -
/// 0x00. Values Range from 0-8. 00 - Normal Operation; 01 - Output Inversion
/// Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs
/// disabled; So on. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc00(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC00, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually
/// turned on or off to conserve power. The system must read the module SPD to
/// determine which clock outputs are used by the module. The PLL remains locked on
/// CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the
/// lowest power mode. Default value - 0x00. Values Range from 0-8. No need to
/// calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc01(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC01, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually
/// turned on or off to conserve power. The system must read the module SPD to
/// determine which clock outputs are used by the module. The PLL remains locked on
/// CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the
/// lowest power mode. Default value - 0x00. Values Range from 0-8. No need to
/// calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc01(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC01, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually
/// turned on or off to conserve power. The system must read the module SPD to
/// determine which clock outputs are used by the module. The PLL remains locked on
/// CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the
/// lowest power mode. Default value - 0x00. Values Range from 0-8. No need to
/// calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc01(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC01, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from
/// 0-8. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC02, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from
/// 0-8. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc02(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC02, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from
/// 0-8. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc02(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC02, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 137, 1st Nibble for CS and CA. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC03, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 137, 1st Nibble for CS and CA. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc03(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC03, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 137, 1st Nibble for CS and CA. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc03(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC03, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default value
/// - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC04, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default value
/// - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc04(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC04, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default value
/// - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc04(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC04, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC05 - Clock Driver Characteristics Control Word; Default value - 0x05
/// (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte
/// 138, 2nd Nibble for CK. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC05, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC05 - Clock Driver Characteristics Control Word; Default value - 0x05
/// (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte
/// 138, 2nd Nibble for CK. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc05(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC05, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC05 - Clock Driver Characteristics Control Word; Default value - 0x05
/// (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte
/// 138, 2nd Nibble for CK. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc05(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC05, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC06_07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. F0RC07 not used. RDIMM creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc06_07(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC06_07, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC06_07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC06_07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. F0RC07 not used. RDIMM creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc06_07(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC06_07, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC06_07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC06_07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. F0RC07 not used. RDIMM creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc06_07(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC06_07, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC06_07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0x03. Values
/// Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
/// 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2; creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc08(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC08, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0x03. Values
/// Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
/// 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2; creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc08(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC08, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0x03. Values
/// Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
/// 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2; creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc08(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC08, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc09(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC09, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc09(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC09, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc09(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC09, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RDIMM Operating Speed; Read from ATTR_MSS_FREQ; Default value - 00. Values Range
/// from 00 to 09. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0a(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0A, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RDIMM Operating Speed; Read from ATTR_MSS_FREQ; Default value - 00. Values Range
/// from 00 to 09. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0a(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0A, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RDIMM Operating Speed; Read from ATTR_MSS_FREQ; Default value - 00. Values Range
/// from 00 to 09. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0a(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0A, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Operating Voltage VDD and VrefCA Source Control Word; Read from
/// ATTR_MSS_VOLT_VDDR. Default value - 14. Values Range from 00 to 15 decimal. No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0b(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0B, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Operating Voltage VDD and VrefCA Source Control Word; Read from
/// ATTR_MSS_VOLT_VDDR. Default value - 14. Values Range from 00 to 15 decimal. No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0b(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0B, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Operating Voltage VDD and VrefCA Source Control Word; Read from
/// ATTR_MSS_VOLT_VDDR. Default value - 14. Values Range from 00 to 15 decimal. No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0b(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0B, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07
/// decimal.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0c(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0C, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07
/// decimal.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0c(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0C, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07
/// decimal.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0c(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0C, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from
/// 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address
/// Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct /
/// Quad CS mode etc); creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0d(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0D, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from
/// 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address
/// Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct /
/// Quad CS mode etc); creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0d(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0D, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from
/// 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address
/// Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct /
/// Quad CS mode etc); creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0d(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0D, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0E - Parity Control Word; Default value - 00. Check from ATTR_EFF_CA_PARITY
/// and assign; Values Range from 00 to 0F. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0e(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0E, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0E - Parity Control Word; Default value - 00. Check from ATTR_EFF_CA_PARITY
/// and assign; Values Range from 00 to 0F. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0e(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0E, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0E - Parity Control Word; Default value - 00. Check from ATTR_EFF_CA_PARITY
/// and assign; Values Range from 00 to 0F. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0e(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0E, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0F - Command Latency Adder Control Word; Default value - 04. Values Range
/// from 00 to 04. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0f(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0F, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0F - Command Latency Adder Control Word; Default value - 04. Values Range
/// from 00 to 04. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0f(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0F, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0F - Command Latency Adder Control Word; Default value - 04. Values Range
/// from 00 to 04. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc0f(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC0F, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00
/// to 3F.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00
/// to 3F.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00
/// to 3F.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC3x - Fine Granularity RDIMM Operating Speed; Default value = (Operating Freq
/// - 1250)/20. Values Range from 00 to 61 Hex. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC3x - Fine Granularity RDIMM Operating Speed; Default value = (Operating Freq
/// - 1250)/20. Values Range from 00 to 61 Hex. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC3x - Fine Granularity RDIMM Operating Speed; Default value = (Operating Freq
/// - 1250)/20. Values Range from 00 to 61 Hex. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from
/// 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from
/// 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from
/// 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal
/// High; Default value - 00. Values Range from 00 to FF. No need to calculate; User
/// can override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal
/// High; Default value - 00. Values Range from 00 to FF. No need to calculate; User
/// can override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal
/// High; Default value - 00. Values Range from 00 to FF. No need to calculate; User
/// can override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC6x: CW Data Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC6x: CW Data Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC6x: CW Data Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need
/// to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_7x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_7x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need
/// to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_7x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_7x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need
/// to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_7x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_7x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
/// Default value - 00. Values Range from 00 to FF. No need to calculate; User can
/// override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_8x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_8x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
/// Default value - 00. Values Range from 00 to FF. No need to calculate; User can
/// override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_8x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_8x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
/// Default value - 00. Values Range from 00 to FF. No need to calculate; User can
/// override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_8x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_8x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF.No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_9x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_9x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF.No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_9x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_9x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF.No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_9x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_9x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Ax getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_ax(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Ax, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Ax: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Ax getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_ax(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Ax, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Ax: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Ax getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_ax(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Ax, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Ax: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Bx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCBx: IBT and MRS Snoop Control Word; Default value - 07. Values Range from 00
/// to FF. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_bx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Bx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Bx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Bx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCBx: IBT and MRS Snoop Control Word; Default value - 07. Values Range from 00
/// to FF. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_bx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Bx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Bx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Bx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCBx: IBT and MRS Snoop Control Word; Default value - 07. Values Range from 00
/// to FF. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc_bx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Bx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Bx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_MIRROR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_mirror_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_MIRROR_MODE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_MIRROR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_MIRROR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_mirror_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_MIRROR_MODE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_MIRROR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_MIRROR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_mirror_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_MIRROR_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_MIRROR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MEMCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_memcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MEMCAL_INTERVAL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MEMCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MEMCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_memcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MEMCAL_INTERVAL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MEMCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MEMCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_memcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MEMCAL_INTERVAL, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MEMCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ZQCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the zqcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_zqcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ZQCAL_INTERVAL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ZQCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ZQCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the zqcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_zqcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ZQCAL_INTERVAL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ZQCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ZQCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the zqcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_zqcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ZQCAL_INTERVAL, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ZQCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of master ranks per DIMM. Represents the number of physical
/// ranks on a DIMM. From SPD spec JEDEC Standard No. 21-C: Page 4.1.2.L-4. Byte 12
/// (Bits 5~3) Number of package ranks per DIMM. Package ranks per DIMM refers to
/// the collections of devices on the module sharing common chip select
/// signals.
///
inline fapi2::ReturnCode eff_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of master ranks per DIMM. Represents the number of physical
/// ranks on a DIMM. From SPD spec JEDEC Standard No. 21-C: Page 4.1.2.L-4. Byte 12
/// (Bits 5~3) Number of package ranks per DIMM. Package ranks per DIMM refers to
/// the collections of devices on the module sharing common chip select
/// signals.
///
inline fapi2::ReturnCode eff_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of master ranks per DIMM. Represents the number of physical
/// ranks on a DIMM. From SPD spec JEDEC Standard No. 21-C: Page 4.1.2.L-4. Byte 12
/// (Bits 5~3) Number of package ranks per DIMM. Package ranks per DIMM refers to
/// the collections of devices on the module sharing common chip select
/// signals.
///
inline fapi2::ReturnCode eff_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RANKS_CONFIGED getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bit wise representation of master ranks in each DIMM that are used for reads and
/// writes. Used by
/// PRD.
///
inline fapi2::ReturnCode eff_dimm_ranks_configed(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RANKS_CONFIGED, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RANKS_CONFIGED: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RANKS_CONFIGED getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bit wise representation of master ranks in each DIMM that are used for reads and
/// writes. Used by
/// PRD.
///
inline fapi2::ReturnCode eff_dimm_ranks_configed(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RANKS_CONFIGED, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RANKS_CONFIGED: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RANKS_CONFIGED getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bit wise representation of master ranks in each DIMM that are used for reads and
/// writes. Used by
/// PRD.
///
inline fapi2::ReturnCode eff_dimm_ranks_configed(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RANKS_CONFIGED, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RANKS_CONFIGED: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_DIE_COUNT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM dies per
/// package.
///
inline fapi2::ReturnCode eff_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_DIE_COUNT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_DIE_COUNT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_DIE_COUNT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM dies per
/// package.
///
inline fapi2::ReturnCode eff_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_DIE_COUNT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_DIE_COUNT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_DIE_COUNT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM dies per
/// package.
///
inline fapi2::ReturnCode eff_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_DIE_COUNT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_DIE_COUNT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled M DRAM clocks setting for cfg_nm_m. creator: mss_eff_cnfg
/// consumer: mss_eff_config_thermal firmware notes:
/// none
///
inline fapi2::ReturnCode mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_M_DRAM_CLOCKS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled M DRAM clocks setting for cfg_nm_m. creator: mss_eff_cnfg
/// consumer: mss_eff_config_thermal firmware notes:
/// none
///
inline fapi2::ReturnCode mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_M_DRAM_CLOCKS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled M DRAM clocks setting for cfg_nm_m. creator: mss_eff_cnfg
/// consumer: mss_eff_config_thermal firmware notes:
/// none
///
inline fapi2::ReturnCode mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_M_DRAM_CLOCKS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_WATT_TARGET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total memory power used to throttle for each dimm Used to compute the throttles
/// on the channel and/or dimms for OCC OCC sets after IPL creator: mss_eff_config
/// consumer: mss_bulk_pwr_throttle, mss_utils_to_throttle firmware notes:
/// none.
///
inline fapi2::ReturnCode mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_WATT_TARGET, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_WATT_TARGET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_WATT_TARGET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total memory power used to throttle for each dimm Used to compute the throttles
/// on the channel and/or dimms for OCC OCC sets after IPL creator: mss_eff_config
/// consumer: mss_bulk_pwr_throttle, mss_utils_to_throttle firmware notes:
/// none.
///
inline fapi2::ReturnCode mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_WATT_TARGET, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_WATT_TARGET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_WATT_TARGET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total memory power used to throttle for each dimm Used to compute the throttles
/// on the channel and/or dimms for OCC OCC sets after IPL creator: mss_eff_config
/// consumer: mss_bulk_pwr_throttle, mss_utils_to_throttle firmware notes:
/// none.
///
inline fapi2::ReturnCode mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_WATT_TARGET, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_WATT_TARGET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_TOTAL_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  VDDR+VPP Power slope value for dimm creator: mss_eff_config consumer:
/// mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode total_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_TOTAL_PWR_SLOPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_TOTAL_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_TOTAL_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  VDDR+VPP Power slope value for dimm creator: mss_eff_config consumer:
/// mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode total_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_TOTAL_PWR_SLOPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_TOTAL_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_TOTAL_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  VDDR+VPP Power slope value for dimm creator: mss_eff_config consumer:
/// mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode total_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_TOTAL_PWR_SLOPE, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_TOTAL_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_TOTAL_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  VDDR+VPP Power intercept value for dimm creator: mss_eff_config consumer:
/// mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode total_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_TOTAL_PWR_INTERCEPT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_TOTAL_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_TOTAL_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  VDDR+VPP Power intercept value for dimm creator: mss_eff_config consumer:
/// mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode total_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_TOTAL_PWR_INTERCEPT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_TOTAL_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_TOTAL_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  VDDR+VPP Power intercept value for dimm creator: mss_eff_config consumer:
/// mss_bulk_pwr_throttles
///
inline fapi2::ReturnCode total_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_TOTAL_PWR_INTERCEPT, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_TOTAL_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DATABUS_UTIL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Databus utilization per port limit used to calculate memory throttles and power
/// limit creator: OCC consumer:
/// mss_utils_to_throttle
///
inline fapi2::ReturnCode databus_util(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DATABUS_UTIL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DATABUS_UTIL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DATABUS_UTIL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Databus utilization per port limit used to calculate memory throttles and power
/// limit creator: OCC consumer:
/// mss_utils_to_throttle
///
inline fapi2::ReturnCode databus_util(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DATABUS_UTIL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DATABUS_UTIL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DATABUS_UTIL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Databus utilization per port limit used to calculate memory throttles and power
/// limit creator: OCC consumer:
/// mss_utils_to_throttle
///
inline fapi2::ReturnCode databus_util(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DATABUS_UTIL, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DATABUS_UTIL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PORT_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode port_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PORT_MAXPOWER, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PORT_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PORT_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode port_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PORT_MAXPOWER, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PORT_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PORT_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode port_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PORT_MAXPOWER, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PORT_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_THERMAL_LIMIT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power based on a thermal limit Decoded from
/// ATTR_MSS_MRW_THERMAL_POWER_LIMIT
///
inline fapi2::ReturnCode dimm_thermal_limit(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_THERMAL_LIMIT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_THERMAL_LIMIT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_THERMAL_LIMIT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power based on a thermal limit Decoded from
/// ATTR_MSS_MRW_THERMAL_POWER_LIMIT
///
inline fapi2::ReturnCode dimm_thermal_limit(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_THERMAL_LIMIT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_THERMAL_LIMIT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_THERMAL_LIMIT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power based on a thermal limit Decoded from
/// ATTR_MSS_MRW_THERMAL_POWER_LIMIT
///
inline fapi2::ReturnCode dimm_thermal_limit(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_THERMAL_LIMIT, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_THERMAL_LIMIT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCA>&
        i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>&
        i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCS>&
        i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCA>&
        i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>&
        i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCS>&
        i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_LPASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_lpasr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_LPASR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_LPASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_LPASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_lpasr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_LPASR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_LPASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_LPASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_lpasr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_LPASR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_LPASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_PAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR Page Selection This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_page(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_PAGE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_PAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_PAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR Page Selection This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_page(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_PAGE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_PAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_PAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR Page Selection This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_page(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_PAGE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_PAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_GEARDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_GEARDOWN_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_GEARDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_GEARDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_GEARDOWN_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_GEARDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_GEARDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_GEARDOWN_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_GEARDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PER_DRAM_ACCESS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Per DRAM accessibility. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_per_dram_access(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PER_DRAM_ACCESS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PER_DRAM_ACCESS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PER_DRAM_ACCESS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Per DRAM accessibility. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_per_dram_access(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PER_DRAM_ACCESS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PER_DRAM_ACCESS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PER_DRAM_ACCESS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Per DRAM accessibility. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_per_dram_access(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PER_DRAM_ACCESS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PER_DRAM_ACCESS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_READOUT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature sensor readout. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_readout(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_READOUT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_READOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_READOUT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature sensor readout. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_readout(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_READOUT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_READOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_READOUT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature sensor readout. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_readout(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_READOUT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_READOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_WR_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  write latency for CRC and DM. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_crc_wr_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_WR_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_WR_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_WR_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  write latency for CRC and DM. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_crc_wr_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_WR_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_WR_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_WR_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  write latency for CRC and DM. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_crc_wr_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_WR_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_WR_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_RD_FORMAT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR READ FORMAT. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_rd_format(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_RD_FORMAT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_RD_FORMAT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_RD_FORMAT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR READ FORMAT. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_rd_format(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_RD_FORMAT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_RD_FORMAT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_RD_FORMAT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR READ FORMAT. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_rd_format(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_RD_FORMAT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_RD_FORMAT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MAX_POWERDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max Power down mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_max_powerdown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MAX_POWERDOWN_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MAX_POWERDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MAX_POWERDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max Power down mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_max_powerdown_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MAX_POWERDOWN_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MAX_POWERDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MAX_POWERDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max Power down mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_max_powerdown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MAX_POWERDOWN_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MAX_POWERDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_INTERNAL_VREF_MONITOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Vref Monitor. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_internal_vref_monitor(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_INTERNAL_VREF_MONITOR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_INTERNAL_VREF_MONITOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_INTERNAL_VREF_MONITOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Vref Monitor. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_internal_vref_monitor(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_INTERNAL_VREF_MONITOR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_INTERNAL_VREF_MONITOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_INTERNAL_VREF_MONITOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Vref Monitor. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_internal_vref_monitor(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_INTERNAL_VREF_MONITOR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_INTERNAL_VREF_MONITOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CS_CMD_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CS_CMD_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CS_CMD_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CS_CMD_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CS_CMD_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CS_CMD_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CS_CMD_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CS_CMD_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CS_CMD_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SELF_REF_ABORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self Refresh Abort. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_self_ref_abort(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SELF_REF_ABORT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SELF_REF_ABORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SELF_REF_ABORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self Refresh Abort. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_self_ref_abort(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SELF_REF_ABORT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SELF_REF_ABORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SELF_REF_ABORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self Refresh Abort. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_self_ref_abort(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SELF_REF_ABORT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SELF_REF_ABORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE_TRAIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble_train(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE_TRAIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE_TRAIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE_TRAIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble_train(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE_TRAIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE_TRAIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE_TRAIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble_train(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE_TRAIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE_TRAIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WR_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WR_PREAMBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WR_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WR_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WR_PREAMBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WR_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WR_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WR_PREAMBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WR_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_ERROR_CLEAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CRC Error Clear. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_crc_error_clear(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_ERROR_CLEAR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_ERROR_CLEAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_ERROR_CLEAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CRC Error Clear. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_crc_error_clear(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_ERROR_CLEAR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_ERROR_CLEAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_ERROR_CLEAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CRC Error Clear. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_crc_error_clear(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_ERROR_CLEAR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_ERROR_CLEAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_ERROR_STATUS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Error Status. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_error_status(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_ERROR_STATUS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_ERROR_STATUS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_ERROR_STATUS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Error Status. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_error_status(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_ERROR_STATUS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_ERROR_STATUS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_ERROR_STATUS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Error Status. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_error_status(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_ERROR_STATUS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_ERROR_STATUS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_INPUT_BUFF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ODT Input Buffer during power down. This is for DDR4 MRS5. Computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_input_buff(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_INPUT_BUFF, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_INPUT_BUFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_INPUT_BUFF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ODT Input Buffer during power down. This is for DDR4 MRS5. Computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_input_buff(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_INPUT_BUFF, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_INPUT_BUFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_INPUT_BUFF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ODT Input Buffer during power down. This is for DDR4 MRS5. Computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_input_buff(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_INPUT_BUFF, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_INPUT_BUFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA Parity Persistance Error. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA Parity Persistance Error. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA Parity Persistance Error. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DATA_MASK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_data_mask(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DATA_MASK, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DATA_MASK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DATA_MASK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_data_mask(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DATA_MASK, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DATA_MASK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DATA_MASK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_data_mask(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DATA_MASK, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DATA_MASK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_DBI, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_dbi(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_DBI, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_DBI, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_READ_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_read_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_READ_DBI, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_READ_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_READ_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_read_dbi(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_READ_DBI, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_READ_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_READ_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_read_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_READ_DBI, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_READ_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_VALUE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_value(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_VALUE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_VALUE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_VALUE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_value(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_VALUE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_VALUE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_VALUE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_value(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_VALUE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_VALUE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train range. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_range(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_RANGE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train range. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_range(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_RANGE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train range. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_range(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_RANGE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train enable. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. Creator: mss_eff_cnfg Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_ENABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train enable. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. Creator: mss_eff_cnfg Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_ENABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_VREF_DQ_TRAIN_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train enable. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. Creator: mss_eff_cnfg Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_vref_dq_train_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_VREF_DQ_TRAIN_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_VREF_DQ_TRAIN_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_crc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_CRC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_crc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_CRC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_crc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_CRC, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_STEP_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit map of vector denoting valid steps to run (0 is left most bit) [0]
/// DRAM_ZQCAL [1] DB_ZQCAL (LRDIMM) [2] MREP (LRDIMM) [3] MRD - Coarse (LRDIMM) [4]
/// MRD - Fine (LRDIMM) [5] WR_LEVEL [6] INITIAL_PAT_WR [7] WR_VREF_LATCH [8] DWL
/// (LRDIMM) [9] MWD - Coarse (LRDIMM) [10] MWD - Fine (LRDIMM) [11] HWL (LRDIMM)
/// [12] DQS_ALIGN [13] RDCLK_ALIGN [14] READ_CTR_2D_VREF [15] READ_CTR [16]
/// WRITE_CTR_2D_VREF [17] WRITE_CTR [18] COARSE_WR [19] COARSE_RD [20]
/// TRAINING_ADV_RD Only set for DD2.* machines [21] TRAINING_ADV_WR Only set for
/// DD2.* machines [22]:[31] Reserved for future use COARSE_WR and COARSE_RD will be
/// consumed together to form COARSE_LVL. WRITE_CTR will be run, even if only
/// WRITE_CTR_2D_VREF is enabled, as the WR 2D VREF HW cal depends upon WRITE_CTR 1D
/// to function. Note: LRDIMM steps will only be enabled for LRDIMMs and won't run
/// on
/// RDIMMs.
///
inline fapi2::ReturnCode cal_step_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_STEP_ENABLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_STEP_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_STEP_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit map of vector denoting valid steps to run (0 is left most bit) [0]
/// DRAM_ZQCAL [1] DB_ZQCAL (LRDIMM) [2] MREP (LRDIMM) [3] MRD - Coarse (LRDIMM) [4]
/// MRD - Fine (LRDIMM) [5] WR_LEVEL [6] INITIAL_PAT_WR [7] WR_VREF_LATCH [8] DWL
/// (LRDIMM) [9] MWD - Coarse (LRDIMM) [10] MWD - Fine (LRDIMM) [11] HWL (LRDIMM)
/// [12] DQS_ALIGN [13] RDCLK_ALIGN [14] READ_CTR_2D_VREF [15] READ_CTR [16]
/// WRITE_CTR_2D_VREF [17] WRITE_CTR [18] COARSE_WR [19] COARSE_RD [20]
/// TRAINING_ADV_RD Only set for DD2.* machines [21] TRAINING_ADV_WR Only set for
/// DD2.* machines [22]:[31] Reserved for future use COARSE_WR and COARSE_RD will be
/// consumed together to form COARSE_LVL. WRITE_CTR will be run, even if only
/// WRITE_CTR_2D_VREF is enabled, as the WR 2D VREF HW cal depends upon WRITE_CTR 1D
/// to function. Note: LRDIMM steps will only be enabled for LRDIMMs and won't run
/// on
/// RDIMMs.
///
inline fapi2::ReturnCode cal_step_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_STEP_ENABLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_STEP_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_STEP_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit map of vector denoting valid steps to run (0 is left most bit) [0]
/// DRAM_ZQCAL [1] DB_ZQCAL (LRDIMM) [2] MREP (LRDIMM) [3] MRD - Coarse (LRDIMM) [4]
/// MRD - Fine (LRDIMM) [5] WR_LEVEL [6] INITIAL_PAT_WR [7] WR_VREF_LATCH [8] DWL
/// (LRDIMM) [9] MWD - Coarse (LRDIMM) [10] MWD - Fine (LRDIMM) [11] HWL (LRDIMM)
/// [12] DQS_ALIGN [13] RDCLK_ALIGN [14] READ_CTR_2D_VREF [15] READ_CTR [16]
/// WRITE_CTR_2D_VREF [17] WRITE_CTR [18] COARSE_WR [19] COARSE_RD [20]
/// TRAINING_ADV_RD Only set for DD2.* machines [21] TRAINING_ADV_WR Only set for
/// DD2.* machines [22]:[31] Reserved for future use COARSE_WR and COARSE_RD will be
/// consumed together to form COARSE_LVL. WRITE_CTR will be run, even if only
/// WRITE_CTR_2D_VREF is enabled, as the WR 2D VREF HW cal depends upon WRITE_CTR 1D
/// to function. Note: LRDIMM steps will only be enabled for LRDIMMs and won't run
/// on
/// RDIMMs.
///
inline fapi2::ReturnCode cal_step_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_STEP_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_STEP_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CUSTOM_TRAINING_ADV_PATTERNS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Special training pattern used in draminit_training_advance. Used for custom
/// pattern read There can be two patterns used here. This attribute is before
/// swizzling for endianness of the registers. CODE WILL SWIZZLE FOR THE SYSTEM The
/// first 0-15 bits are for PATTERN0, bits 16-32 are for PATTERN1. If this attribute
/// is set to 0, using the default values of: 0x8E94 for PATTERN0 0x2BC6 for
/// PATTERN1 Set to default in
/// eff_config
///
inline fapi2::ReturnCode custom_training_adv_patterns(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CUSTOM_TRAINING_ADV_PATTERNS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CUSTOM_TRAINING_ADV_PATTERNS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CUSTOM_TRAINING_ADV_PATTERNS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Special training pattern used in draminit_training_advance. Used for custom
/// pattern read There can be two patterns used here. This attribute is before
/// swizzling for endianness of the registers. CODE WILL SWIZZLE FOR THE SYSTEM The
/// first 0-15 bits are for PATTERN0, bits 16-32 are for PATTERN1. If this attribute
/// is set to 0, using the default values of: 0x8E94 for PATTERN0 0x2BC6 for
/// PATTERN1 Set to default in
/// eff_config
///
inline fapi2::ReturnCode custom_training_adv_patterns(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CUSTOM_TRAINING_ADV_PATTERNS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CUSTOM_TRAINING_ADV_PATTERNS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CUSTOM_TRAINING_ADV_PATTERNS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Special training pattern used in draminit_training_advance. Used for custom
/// pattern read There can be two patterns used here. This attribute is before
/// swizzling for endianness of the registers. CODE WILL SWIZZLE FOR THE SYSTEM The
/// first 0-15 bits are for PATTERN0, bits 16-32 are for PATTERN1. If this attribute
/// is set to 0, using the default values of: 0x8E94 for PATTERN0 0x2BC6 for
/// PATTERN1 Set to default in
/// eff_config
///
inline fapi2::ReturnCode custom_training_adv_patterns(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CUSTOM_TRAINING_ADV_PATTERNS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CUSTOM_TRAINING_ADV_PATTERNS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Special training backup pattern Used for custom_pattern_read in
/// draminit_training_advance. If the main patterns fail, the code will try running
/// this pattern Used for read centering There can be two patterns used here. This
/// attribute is before swizzling for endianness of the registers. CODE WILL SWIZZLE
/// FOR THE SYSTEM The first 0-15 bits are for PATTERN0, bits 16-32 are for
/// PATTERN1. If this attribute is set to 0, using the default values of: 0xEA0C for
/// PATTERN0 0xA6C9 for PATTERN1 Set to default in
/// eff_config
///
inline fapi2::ReturnCode custom_training_adv_backup_patterns(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Special training backup pattern Used for custom_pattern_read in
/// draminit_training_advance. If the main patterns fail, the code will try running
/// this pattern Used for read centering There can be two patterns used here. This
/// attribute is before swizzling for endianness of the registers. CODE WILL SWIZZLE
/// FOR THE SYSTEM The first 0-15 bits are for PATTERN0, bits 16-32 are for
/// PATTERN1. If this attribute is set to 0, using the default values of: 0xEA0C for
/// PATTERN0 0xA6C9 for PATTERN1 Set to default in
/// eff_config
///
inline fapi2::ReturnCode custom_training_adv_backup_patterns(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Special training backup pattern Used for custom_pattern_read in
/// draminit_training_advance. If the main patterns fail, the code will try running
/// this pattern Used for read centering There can be two patterns used here. This
/// attribute is before swizzling for endianness of the registers. CODE WILL SWIZZLE
/// FOR THE SYSTEM The first 0-15 bits are for PATTERN0, bits 16-32 are for
/// PATTERN1. If this attribute is set to 0, using the default values of: 0xEA0C for
/// PATTERN0 0xA6C9 for PATTERN1 Set to default in
/// eff_config
///
inline fapi2::ReturnCode custom_training_adv_backup_patterns(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Special training backup pattern number 2 Used for custom_pattern_read in
/// draminit_training_advance. If the main patterns fail, the code will try running
/// this pattern Used for read centering There can be two patterns used here. This
/// attribute is before swizzling for endianness of the registers. CODE WILL SWIZZLE
/// FOR THE SYSTEM The first 0-15 bits are for PATTERN0, bits 16-32 are for
/// PATTERN1. If this attribute is set to 0, using the default values of: 0x13EC for
/// PATTERN0 0x02FD for PATTERN1 Set to default in
/// eff_config
///
inline fapi2::ReturnCode custom_training_adv_backup_patterns2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS2,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Special training backup pattern number 2 Used for custom_pattern_read in
/// draminit_training_advance. If the main patterns fail, the code will try running
/// this pattern Used for read centering There can be two patterns used here. This
/// attribute is before swizzling for endianness of the registers. CODE WILL SWIZZLE
/// FOR THE SYSTEM The first 0-15 bits are for PATTERN0, bits 16-32 are for
/// PATTERN1. If this attribute is set to 0, using the default values of: 0x13EC for
/// PATTERN0 0x02FD for PATTERN1 Set to default in
/// eff_config
///
inline fapi2::ReturnCode custom_training_adv_backup_patterns2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Special training backup pattern number 2 Used for custom_pattern_read in
/// draminit_training_advance. If the main patterns fail, the code will try running
/// this pattern Used for read centering There can be two patterns used here. This
/// attribute is before swizzling for endianness of the registers. CODE WILL SWIZZLE
/// FOR THE SYSTEM The first 0-15 bits are for PATTERN0, bits 16-32 are for
/// PATTERN1. If this attribute is set to 0, using the default values of: 0x13EC for
/// PATTERN0 0x02FD for PATTERN1 Set to default in
/// eff_config
///
inline fapi2::ReturnCode custom_training_adv_backup_patterns2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS2, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CUSTOM_TRAINING_ADV_BACKUP_PATTERNS2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CUSTOM_TRAINING_ADV_WR_PATTERN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Special training pattern used in draminit_training_advance. Used for custom
/// pattern write Due to hardware limitations, only one 8-bit pattern can be used
/// This attribute is before swizzling for endianness of the registers. CODE WILL
/// SWIZZLE FOR THE SYSTEM If this attribute is set to 0, using the default values
/// of: 0x9A Set to default in
/// eff_config
///
inline fapi2::ReturnCode custom_training_adv_wr_pattern(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CUSTOM_TRAINING_ADV_WR_PATTERN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CUSTOM_TRAINING_ADV_WR_PATTERN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CUSTOM_TRAINING_ADV_WR_PATTERN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Special training pattern used in draminit_training_advance. Used for custom
/// pattern write Due to hardware limitations, only one 8-bit pattern can be used
/// This attribute is before swizzling for endianness of the registers. CODE WILL
/// SWIZZLE FOR THE SYSTEM If this attribute is set to 0, using the default values
/// of: 0x9A Set to default in
/// eff_config
///
inline fapi2::ReturnCode custom_training_adv_wr_pattern(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CUSTOM_TRAINING_ADV_WR_PATTERN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CUSTOM_TRAINING_ADV_WR_PATTERN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CUSTOM_TRAINING_ADV_WR_PATTERN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Special training pattern used in draminit_training_advance. Used for custom
/// pattern write Due to hardware limitations, only one 8-bit pattern can be used
/// This attribute is before swizzling for endianness of the registers. CODE WILL
/// SWIZZLE FOR THE SYSTEM If this attribute is set to 0, using the default values
/// of: 0x9A Set to default in
/// eff_config
///
inline fapi2::ReturnCode custom_training_adv_wr_pattern(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CUSTOM_TRAINING_ADV_WR_PATTERN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CUSTOM_TRAINING_ADV_WR_PATTERN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VREF_CAL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting bits in every DP16 on the port to be calibrated. That is,
/// all of the set bits will be calibrated for all DP16. A value of zero indicates
/// the calibration should not be
/// run.
///
inline fapi2::ReturnCode vref_cal_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VREF_CAL_ENABLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VREF_CAL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VREF_CAL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting bits in every DP16 on the port to be calibrated. That is,
/// all of the set bits will be calibrated for all DP16. A value of zero indicates
/// the calibration should not be
/// run.
///
inline fapi2::ReturnCode vref_cal_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VREF_CAL_ENABLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VREF_CAL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VREF_CAL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting bits in every DP16 on the port to be calibrated. That is,
/// all of the set bits will be calibrated for all DP16. A value of zero indicates
/// the calibration should not be
/// run.
///
inline fapi2::ReturnCode vref_cal_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VREF_CAL_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VREF_CAL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RDVREF_CAL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting bits in every DP16 on the port to be calibrated. That is,
/// all of the set bits will be calibrated for all DP16. A value of zero indicates
/// the calibration should not be
/// run.
///
inline fapi2::ReturnCode rdvref_cal_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RDVREF_CAL_ENABLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RDVREF_CAL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RDVREF_CAL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting bits in every DP16 on the port to be calibrated. That is,
/// all of the set bits will be calibrated for all DP16. A value of zero indicates
/// the calibration should not be
/// run.
///
inline fapi2::ReturnCode rdvref_cal_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RDVREF_CAL_ENABLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RDVREF_CAL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RDVREF_CAL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting bits in every DP16 on the port to be calibrated. That is,
/// all of the set bits will be calibrated for all DP16. A value of zero indicates
/// the calibration should not be
/// run.
///
inline fapi2::ReturnCode rdvref_cal_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RDVREF_CAL_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RDVREF_CAL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_ABORT_ON_ERROR getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Whether or not to abort on the first DDR PHY calibration error. Firmware should
/// always have this set to NO. YES can be used in the lab for troubleshooting,
/// screening,
/// etc.
///
inline fapi2::ReturnCode cal_abort_on_error(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_ABORT_ON_ERROR, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_ABORT_ON_ERROR: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VREF_DAC_NIBBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value for VREF DAC
/// nibble
///
inline fapi2::ReturnCode vref_dac_nibble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VREF_DAC_NIBBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VREF_DAC_NIBBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VREF_DAC_NIBBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value for VREF DAC
/// nibble
///
inline fapi2::ReturnCode vref_dac_nibble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VREF_DAC_NIBBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VREF_DAC_NIBBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VREF_DAC_NIBBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value for VREF DAC
/// nibble
///
inline fapi2::ReturnCode vref_dac_nibble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VREF_DAC_NIBBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VREF_DAC_NIBBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_NOM value read to be programmed into MRS02 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_NOM value read to be programmed into MRS02 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_NOM value read to be programmed into MRS02 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_NOM, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_WR value read to be programmed into MRS02 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_WR value read to be programmed into MRS02 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_WR value read to be programmed into MRS02 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_PARK value read to be programmed into MRS05 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_PARK value read to be programmed into MRS05 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_PARK value read to be programmed into MRS05 For RDIMMS, this is based off of
/// the VPD For LRDIMMS, this comes from the
/// SPD
///
inline fapi2::ReturnCode eff_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_PARK, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW00 Host Interface DQ RTT_NOM
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC00, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW00 Host Interface DQ RTT_NOM
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc00(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC00, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW00 Host Interface DQ RTT_NOM
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc00(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC00, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW01 Host Interface DQ RTT_WR
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc01(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC01, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW01 Host Interface DQ RTT_WR
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc01(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC01, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW01 Host Interface DQ RTT_WR
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc01(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC01, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW02 Host Interface DQ RTT_PARK
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC02, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW02 Host Interface DQ RTT_PARK
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc02(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC02, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW02 Host Interface DQ RTT_PARK
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc02(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC02, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW03 Host Interface DQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC03, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW03 Host Interface DQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc03(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC03, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW03 Host Interface DQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc03(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC03, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW04 DRAM Interface MDQ RTT Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC04, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW04 DRAM Interface MDQ RTT Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc04(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC04, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW04 DRAM Interface MDQ RTT Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc04(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC04, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW05 DRAM Interface MDQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC05, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW05 DRAM Interface MDQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc05(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC05, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW05 DRAM Interface MDQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc05(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC05, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW06 Command Space Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc06(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC06, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW06 Command Space Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc06(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC06, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW06 Command Space Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc06(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC06, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW07 Rank Presence Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc07(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC07, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW07 Rank Presence Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc07(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC07, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW07 Rank Presence Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc07(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC07, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW08 RankSelection Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc08(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC08, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW08 RankSelection Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc08(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC08, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW08 RankSelection Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc08(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC08, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW09 Power Saving Settings Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc09(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC09, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW09 Power Saving Settings Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc09(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC09, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW09 Power Saving Settings Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc09(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC09, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0A LRDIMM Operating
/// Speed
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0a(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0A, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0A LRDIMM Operating
/// Speed
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0a(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0A, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0A LRDIMM Operating
/// Speed
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0a(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0A, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0B Operating Voltage Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0b(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0B, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0B Operating Voltage Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0b(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0B, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0B Operating Voltage Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0b(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0B, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0C Buffer Training Mode Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0c(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0C, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0C Buffer Training Mode Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0c(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0C, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0C Buffer Training Mode Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0c(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0C, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0D Reserved for future
/// use
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0d(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0D, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0D Reserved for future
/// use
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0d(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0D, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0D Reserved for future
/// use
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0d(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0D, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0E Parity Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0e(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0E, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0E Parity Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0e(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0E, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0E Parity Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0e(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0E, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0F Error Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0f(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0F, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0F Error Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0f(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0F, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0F Error Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0f(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0F, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW1x Buffer Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW1x Buffer Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW1x Buffer Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW6x Fine Granularity Frequency Operating Speed Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW6x Fine Granularity Frequency Operating Speed Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW6x Fine Granularity Frequency Operating Speed Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F2BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F2BCWEx Host Interface DFE Programming Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f2bcex(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F2BCEx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F2BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F2BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F2BCWEx Host Interface DFE Programming Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f2bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F2BCEx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F2BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F2BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F2BCWEx Host Interface DFE Programming Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f2bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F2BCEx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F2BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW5x Host Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW5x Host Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW5x Host Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW6x DRAM Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW6x DRAM Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW6x DRAM Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW4x Buffer Training Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW4x Buffer Training Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW4x Buffer Training Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TDQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TDQS. Used in various locations and is computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tdqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TDQS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TDQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TDQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TDQS. Used in various locations and is computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tdqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TDQS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TDQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TDQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TDQS. Used in various locations and is computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tdqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TDQS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TDQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ODIC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM output driver impedance control
/// (ODIC)
///
inline fapi2::ReturnCode eff_dram_odic(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ODIC, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ODIC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ODIC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM output driver impedance control
/// (ODIC)
///
inline fapi2::ReturnCode eff_dram_odic(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ODIC, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ODIC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ODIC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM output driver impedance control
/// (ODIC)
///
inline fapi2::ReturnCode eff_dram_odic(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ODIC, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ODIC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_LRDIMM_TRAINING_PATTERN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Patterns for LRDIMM training
/// steps
///
inline fapi2::ReturnCode lrdimm_training_pattern(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[5];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_LRDIMM_TRAINING_PATTERN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_LRDIMM_TRAINING_PATTERN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_LRDIMM_TRAINING_PATTERN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Patterns for LRDIMM training
/// steps
///
inline fapi2::ReturnCode lrdimm_training_pattern(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[5];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_LRDIMM_TRAINING_PATTERN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_LRDIMM_TRAINING_PATTERN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_LRDIMM_TRAINING_PATTERN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Patterns for LRDIMM training
/// steps
///
inline fapi2::ReturnCode lrdimm_training_pattern(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[5];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_LRDIMM_TRAINING_PATTERN, i_target, l_value) );
    memcpy(o_array, &l_value, 5);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_LRDIMM_TRAINING_PATTERN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  READ, On Die Termination triggering bitmap. Use bitmap to determine which ODT to
/// fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1 ODT1][N/A][N/A] Attribute is derived from VPD
/// for RDIMM or from termination settings for
/// LRDIMM
///
inline fapi2::ReturnCode eff_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_ODT_RD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  READ, On Die Termination triggering bitmap. Use bitmap to determine which ODT to
/// fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1 ODT1][N/A][N/A] Attribute is derived from VPD
/// for RDIMM or from termination settings for
/// LRDIMM
///
inline fapi2::ReturnCode eff_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_ODT_RD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  READ, On Die Termination triggering bitmap. Use bitmap to determine which ODT to
/// fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1 ODT1][N/A][N/A] Attribute is derived from VPD
/// for RDIMM or from termination settings for
/// LRDIMM
///
inline fapi2::ReturnCode eff_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_ODT_RD, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  WRITE, On Die Termination triggering bitmap. Use bitmap to determine which ODT
/// to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1 ODT1][N/A][N/A] Attribute is derived from VPD
/// for RDIMM or from termination settings for
/// LRDIMM
///
inline fapi2::ReturnCode eff_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_ODT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  WRITE, On Die Termination triggering bitmap. Use bitmap to determine which ODT
/// to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1 ODT1][N/A][N/A] Attribute is derived from VPD
/// for RDIMM or from termination settings for
/// LRDIMM
///
inline fapi2::ReturnCode eff_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_ODT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  WRITE, On Die Termination triggering bitmap. Use bitmap to determine which ODT
/// to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1 ODT1][N/A][N/A] Attribute is derived from VPD
/// for RDIMM or from termination settings for
/// LRDIMM
///
inline fapi2::ReturnCode eff_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_ODT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DPHY_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write latency offset in number of
/// clocks
///
inline fapi2::ReturnCode eff_dphy_wlo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DPHY_WLO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DPHY_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DPHY_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write latency offset in number of
/// clocks
///
inline fapi2::ReturnCode eff_dphy_wlo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DPHY_WLO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DPHY_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DPHY_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write latency offset in number of
/// clocks
///
inline fapi2::ReturnCode eff_dphy_wlo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DPHY_WLO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DPHY_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DPHY_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read latency offset in number of
/// clocks
///
inline fapi2::ReturnCode eff_dphy_rlo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DPHY_RLO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DPHY_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DPHY_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read latency offset in number of
/// clocks
///
inline fapi2::ReturnCode eff_dphy_rlo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DPHY_RLO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DPHY_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DPHY_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read latency offset in number of
/// clocks
///
inline fapi2::ReturnCode eff_dphy_rlo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DPHY_RLO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DPHY_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TREFI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Average Refresh Interval (tREFI) in nck (number of clock cycles). This depends
/// on MRW attribute that selects fine refresh mode (x1, x2, x4). From DDR4 spec
/// (79-4A). For 3DS, the tREFI time to the same logical rank is defined as
/// tRFC_slr1, tRFC_slr2, or tRFC_slr4. creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TREFI, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TREFI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Average Refresh Interval (tREFI) in nck (number of clock cycles). This depends
/// on MRW attribute that selects fine refresh mode (x1, x2, x4). From DDR4 spec
/// (79-4A). For 3DS, the tREFI time to the same logical rank is defined as
/// tRFC_slr1, tRFC_slr2, or tRFC_slr4. creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TREFI, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TREFI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Average Refresh Interval (tREFI) in nck (number of clock cycles). This depends
/// on MRW attribute that selects fine refresh mode (x1, x2, x4). From DDR4 spec
/// (79-4A). For 3DS, the tREFI time to the same logical rank is defined as
/// tRFC_slr1, tRFC_slr2, or tRFC_slr4. creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TREFI, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRTP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. From the DDR4 spec (79-4A). Each memory
/// channel will have a value. creator: mss_eff_cnfg_timing consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRTP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRTP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. From the DDR4 spec (79-4A). Each memory
/// channel will have a value. creator: mss_eff_cnfg_timing consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRTP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRTP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. From the DDR4 spec (79-4A). Each memory
/// channel will have a value. creator: mss_eff_cnfg_timing consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRTP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Refresh Recovery Delay Time (different logical ranks) in nck (number of
/// clock cyles). Selected tRFC value (tRFC_dlr1, tRFC_dlr2, or tRFC_dlr4) depends
/// on MRW attribute that selects fine refresh mode (x1, x2, x4). For 3DS, The tRFC
/// time to different logical ranks are defined as tRFC_dlr creator: eff_config
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC_DLR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Refresh Recovery Delay Time (different logical ranks) in nck (number of
/// clock cyles). Selected tRFC value (tRFC_dlr1, tRFC_dlr2, or tRFC_dlr4) depends
/// on MRW attribute that selects fine refresh mode (x1, x2, x4). For 3DS, The tRFC
/// time to different logical ranks are defined as tRFC_dlr creator: eff_config
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc_dlr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC_DLR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Refresh Recovery Delay Time (different logical ranks) in nck (number of
/// clock cyles). Selected tRFC value (tRFC_dlr1, tRFC_dlr2, or tRFC_dlr4) depends
/// on MRW attribute that selects fine refresh mode (x1, x2, x4). For 3DS, The tRFC
/// time to different logical ranks are defined as tRFC_dlr creator: eff_config
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC_DLR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). For
/// 3DS, the tFAW time to different logical ranks are defined as tFAW_dlr Each
/// memory channel will have a value. creator: eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW_DLR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). For
/// 3DS, the tFAW time to different logical ranks are defined as tFAW_dlr Each
/// memory channel will have a value. creator: eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw_dlr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW_DLR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). For
/// 3DS, the tFAW time to different logical ranks are defined as tFAW_dlr Each
/// memory channel will have a value. creator: eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW_DLR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time (different logical ranks) in nck (number
/// of clock cycles). For 3DS, The tRRD_S time to a different logical rank is
/// defined as tRRD_dlr. Each memory channel will have a value. creator: eff_confg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_DLR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time (different logical ranks) in nck (number
/// of clock cycles). For 3DS, The tRRD_S time to a different logical rank is
/// defined as tRRD_dlr. Each memory channel will have a value. creator: eff_confg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_dlr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_DLR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_DLR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time (different logical ranks) in nck (number
/// of clock cycles). For 3DS, The tRRD_S time to a different logical rank is
/// defined as tRRD_dlr. Each memory channel will have a value. creator: eff_confg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_dlr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_DLR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_DLR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_IGNORE_PLUG_RULES getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Set to IGNORE if you want to ignore the plug rules. Sometimes this is needed in
/// a partial-good
/// configuration
///
inline fapi2::ReturnCode ignore_plug_rules(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_IGNORE_PLUG_RULES, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_IGNORE_PLUG_RULES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MVPD_FWMS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Mark store records from MPVD Lx
/// keyword
///
inline fapi2::ReturnCode mvpd_fwms(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][8];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MVPD_FWMS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MVPD_FWMS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MVPD_FWMS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Mark store records from MPVD Lx
/// keyword
///
inline fapi2::ReturnCode mvpd_fwms(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][8];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MVPD_FWMS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MVPD_FWMS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MVPD_FWMS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Mark store records from MPVD Lx
/// keyword
///
inline fapi2::ReturnCode mvpd_fwms(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][8];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MVPD_FWMS, i_target, l_value) );
    memcpy(o_array, &l_value, 64);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MVPD_FWMS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_REORDER_QUEUE_SETTING getter
/// @param[in] const ref to the TARGET_TYPE_MCBIST
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Contains the settings for write/read reorder
/// queue
///
inline fapi2::ReturnCode reorder_queue_setting(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_REORDER_QUEUE_SETTING, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_REORDER_QUEUE_SETTING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RANK_GROUP_OVERRIDE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Override PHY rank group settings. The two uint16 values map to rank
/// group0/1(Pri/Sec ranks) for unt16[X][0] and rank group2/3(Pri/Sec ranks) for
/// uint16[X][1]. Bits map as follows: uint16[X][0]: (0:2)=RP0_primary,
/// (3)=RP0_primary_valid, (4:6)=RP0_secondary, (7)=RP0_secondary_valid,
/// (8:10)=RP1_primary, (11)=RP1_primary_valid, (12:14)=RP1_secondary,
/// (15)=RP1_secondary_valid, uint16[X][1]: (0:2)=RP2_primary,
/// (3)=RP2_primary_valid, (4:6)=RP2_secondary, (7)=RP2_secondary_valid,
/// (8:10)=RP3_primary, (11)=RP3_primary_valid, (12:14)=RP3_secondary,
/// (15)=RP3_secondary_valid. Note: that the DIMM1 ranks in a dual-drop config are
/// stored in the attribute as the centaur canonical number (4,5). The code will
/// automatically do the conversion from the Centaur canonical to the correct PHY
/// nomenclature (2,3 for 4,5 respectively). Set this attribute to zero to use
/// default
/// settings.
///
inline fapi2::ReturnCode eff_rank_group_override(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RANK_GROUP_OVERRIDE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RANK_GROUP_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RANK_GROUP_OVERRIDE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Override PHY rank group settings. The two uint16 values map to rank
/// group0/1(Pri/Sec ranks) for unt16[X][0] and rank group2/3(Pri/Sec ranks) for
/// uint16[X][1]. Bits map as follows: uint16[X][0]: (0:2)=RP0_primary,
/// (3)=RP0_primary_valid, (4:6)=RP0_secondary, (7)=RP0_secondary_valid,
/// (8:10)=RP1_primary, (11)=RP1_primary_valid, (12:14)=RP1_secondary,
/// (15)=RP1_secondary_valid, uint16[X][1]: (0:2)=RP2_primary,
/// (3)=RP2_primary_valid, (4:6)=RP2_secondary, (7)=RP2_secondary_valid,
/// (8:10)=RP3_primary, (11)=RP3_primary_valid, (12:14)=RP3_secondary,
/// (15)=RP3_secondary_valid. Note: that the DIMM1 ranks in a dual-drop config are
/// stored in the attribute as the centaur canonical number (4,5). The code will
/// automatically do the conversion from the Centaur canonical to the correct PHY
/// nomenclature (2,3 for 4,5 respectively). Set this attribute to zero to use
/// default
/// settings.
///
inline fapi2::ReturnCode eff_rank_group_override(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RANK_GROUP_OVERRIDE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RANK_GROUP_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RANK_GROUP_OVERRIDE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Override PHY rank group settings. The two uint16 values map to rank
/// group0/1(Pri/Sec ranks) for unt16[X][0] and rank group2/3(Pri/Sec ranks) for
/// uint16[X][1]. Bits map as follows: uint16[X][0]: (0:2)=RP0_primary,
/// (3)=RP0_primary_valid, (4:6)=RP0_secondary, (7)=RP0_secondary_valid,
/// (8:10)=RP1_primary, (11)=RP1_primary_valid, (12:14)=RP1_secondary,
/// (15)=RP1_secondary_valid, uint16[X][1]: (0:2)=RP2_primary,
/// (3)=RP2_primary_valid, (4:6)=RP2_secondary, (7)=RP2_secondary_valid,
/// (8:10)=RP3_primary, (11)=RP3_primary_valid, (12:14)=RP3_secondary,
/// (15)=RP3_secondary_valid. Note: that the DIMM1 ranks in a dual-drop config are
/// stored in the attribute as the centaur canonical number (4,5). The code will
/// automatically do the conversion from the Centaur canonical to the correct PHY
/// nomenclature (2,3 for 4,5 respectively). Set this attribute to zero to use
/// default
/// settings.
///
inline fapi2::ReturnCode eff_rank_group_override(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RANK_GROUP_OVERRIDE, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RANK_GROUP_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Set equal to 1 to disable setting of RTT_NOM to use RTT_WR values during
/// WR_LEVEL
/// calibration.
///
inline fapi2::ReturnCode rtt_nom_override_disable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Set equal to 1 to disable setting of RTT_NOM to use RTT_WR values during
/// WR_LEVEL
/// calibration.
///
inline fapi2::ReturnCode rtt_nom_override_disable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Set equal to 1 to disable setting of RTT_NOM to use RTT_WR values during
/// WR_LEVEL
/// calibration.
///
inline fapi2::ReturnCode rtt_nom_override_disable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_WR_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Controls ENABLE/DISABLE of Write
/// CRC
///
inline fapi2::ReturnCode eff_wr_crc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_WR_CRC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_WR_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_WR_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Controls ENABLE/DISABLE of Write
/// CRC
///
inline fapi2::ReturnCode eff_wr_crc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_WR_CRC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_WR_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_WR_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Controls ENABLE/DISABLE of Write
/// CRC
///
inline fapi2::ReturnCode eff_wr_crc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_WR_CRC, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_WR_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PHY_SEQ_REFRESH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Controls ENABLE/DISABLE of workaround that sets the PHY sequencer to trigger
/// refresh after
/// draminit.
///
inline fapi2::ReturnCode phy_seq_refresh(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PHY_SEQ_REFRESH, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PHY_SEQ_REFRESH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PHY_SEQ_REFRESH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Controls ENABLE/DISABLE of workaround that sets the PHY sequencer to trigger
/// refresh after
/// draminit.
///
inline fapi2::ReturnCode phy_seq_refresh(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PHY_SEQ_REFRESH, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PHY_SEQ_REFRESH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PHY_SEQ_REFRESH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Controls ENABLE/DISABLE of workaround that sets the PHY sequencer to trigger
/// refresh after
/// draminit.
///
inline fapi2::ReturnCode phy_seq_refresh(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PHY_SEQ_REFRESH, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PHY_SEQ_REFRESH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_WR_VREF_OFFSET getter
/// @param[in] const ref to the TARGET_TYPE_MCBIST
/// @param[out] int8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Offsets the WR VREF value from the VPD when creating the eff config WR VREF
/// attributes.
///
inline fapi2::ReturnCode wr_vref_offset(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, int8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_WR_VREF_OFFSET, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_WR_VREF_OFFSET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SBE_NVDIMM_IN_PORT getter
/// @param[in] const ref to the TARGET_TYPE_PROC_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (PROC_CHIP)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bitmap to indicate which ports under the processor have NVDIMM plugged. This
/// is needed to support SBE to trigger CSAVE during controlled shutdown, warm
/// reboot, and MPIPL. For example, 0b11000000 indicates port 0 and 1 contain
/// NVDIMMs. creator: eff_confg consumer:
/// SBE
///
inline fapi2::ReturnCode sbe_nvdimm_in_port(const fapi2::Target<fapi2::TARGET_TYPE_PROC_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SBE_NVDIMM_IN_PORT, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SBE_NVDIMM_IN_PORT: 0x%lx (proc chip target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_EFF_DRAM_GEN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_GEN, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_GEN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_GEN, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_GEN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Type. Decodes SPD byte 2. Generation of memory: DDR3, DDR4. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_GEN, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM, UDIMM,
/// LRDIMM as specified by the JEDEC standard. creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM, UDIMM,
/// LRDIMM as specified by the JEDEC standard. creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0). Type of DIMM: RDIMM, UDIMM,
/// LRDIMM as specified by the JEDEC standard. creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID_MEMORY_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID_MEMORY_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID_MEMORY_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per die. For
/// multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each DRAM
/// die in the stack. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DENSITY, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per die. For
/// multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each DRAM
/// die in the stack. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DENSITY, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per die. For
/// multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each DRAM
/// die in the stack. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DENSITY, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of DRAM bank address bits. Actual number of banks is 2^N, where N is the
/// number of bank address bits. Decodes SPD Byte 4 (bits 5~4). creator: spd_decoder
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of DRAM bank address bits. Actual number of banks is 2^N, where N is the
/// number of bank address bits. Decodes SPD Byte 4 (bits 5~4). creator: spd_decoder
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of DRAM bank address bits. Actual number of banks is 2^N, where N is the
/// number of bank address bits. Decodes SPD Byte 4 (bits 5~4). creator: spd_decoder
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address bits.
/// Actual number of DRAM rows is 2^N, where N is the number of row address bits
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ROW_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address bits.
/// Actual number of DRAM rows is 2^N, where N is the number of row address bits
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ROW_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address bits.
/// Actual number of DRAM rows is 2^N, where N is the number of row address bits
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ROW_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary set of
/// SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_STACK_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary set of
/// SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_STACK_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary set of
/// SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_STACK_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PPR, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PPR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PPR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Soft Post Package Repair. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SOFT_PPR, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Soft Post Package Repair. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SOFT_PPR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Soft Post Package Repair. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SOFT_PPR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRCD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum RAS to CAS Delay Time in nck (number of clock cyles). Decodes SPD byte
/// 25 (7~0) and byte 112 (7~0). Each memory channel will have a value. creator:
/// eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRCD, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRCD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum RAS to CAS Delay Time in nck (number of clock cyles). Decodes SPD byte
/// 25 (7~0) and byte 112 (7~0). Each memory channel will have a value. creator:
/// eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRCD, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRCD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum RAS to CAS Delay Time in nck (number of clock cyles). Decodes SPD byte
/// 25 (7~0) and byte 112 (7~0). Each memory channel will have a value. creator:
/// eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRCD, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Row Precharge Delay Time in nck (number of clock cycles). Decodes SPD byte
/// 26 (bits 7~0) and byte 121 (bits 7~0). Each memory channel will have a value.
/// creator: eff_config consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Row Precharge Delay Time in nck (number of clock cycles). Decodes SPD byte
/// 26 (bits 7~0) and byte 121 (bits 7~0). Each memory channel will have a value.
/// creator: eff_config consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Row Precharge Delay Time in nck (number of clock cycles). Decodes SPD byte
/// 26 (bits 7~0) and byte 121 (bits 7~0). Each memory channel will have a value.
/// creator: eff_config consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRAS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Precharge Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 27 (bits 3~0) and byte 28 (7~0). Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRAS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRAS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Precharge Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 27 (bits 3~0) and byte 28 (7~0). Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRAS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRAS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Precharge Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 27 (bits 3~0) and byte 28 (7~0). Each memory channel will have a value.
/// creator: mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRAS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Active/Refresh Delay in nck (number of clock cyles). Decodes
/// SPD byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120. Each memory channel
/// will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Active/Refresh Delay in nck (number of clock cyles). Decodes
/// SPD byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120. Each memory channel
/// will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Active to Active/Refresh Delay in nck (number of clock cyles). Decodes
/// SPD byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120. Each memory channel
/// will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRC, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DDR4 Spec defined as Refresh Cycle Time (tRFC). SPD Spec refers it to the
/// Minimum Refresh Recovery Delay Time. In nck (number of clock cyles). Decodes SPD
/// byte 31 (bits 15~8) and byte 30 (bits 7~0) for tRFC1. Decodes SPD byte 33 (bits
/// 15~8) and byte 32 (bits 7~0) for tRFC2. Decodes SPD byte 35 (bits 15~8) and byte
/// 34 (bits 7~0) for tRFC4. Selected tRFC value depends on MRW attribute that
/// selects refresh mode. For 3DS, The tRFC time to the same logical rank is defined
/// as tRFC_slr and is specificed as the value as for a monolithic DDR4 SDRAM of
/// equivalent density. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DDR4 Spec defined as Refresh Cycle Time (tRFC). SPD Spec refers it to the
/// Minimum Refresh Recovery Delay Time. In nck (number of clock cyles). Decodes SPD
/// byte 31 (bits 15~8) and byte 30 (bits 7~0) for tRFC1. Decodes SPD byte 33 (bits
/// 15~8) and byte 32 (bits 7~0) for tRFC2. Decodes SPD byte 35 (bits 15~8) and byte
/// 34 (bits 7~0) for tRFC4. Selected tRFC value depends on MRW attribute that
/// selects refresh mode. For 3DS, The tRFC time to the same logical rank is defined
/// as tRFC_slr and is specificed as the value as for a monolithic DDR4 SDRAM of
/// equivalent density. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DDR4 Spec defined as Refresh Cycle Time (tRFC). SPD Spec refers it to the
/// Minimum Refresh Recovery Delay Time. In nck (number of clock cyles). Decodes SPD
/// byte 31 (bits 15~8) and byte 30 (bits 7~0) for tRFC1. Decodes SPD byte 33 (bits
/// 15~8) and byte 32 (bits 7~0) for tRFC2. Decodes SPD byte 35 (bits 15~8) and byte
/// 34 (bits 7~0) for tRFC4. Selected tRFC value depends on MRW attribute that
/// selects refresh mode. For 3DS, The tRFC time to the same logical rank is defined
/// as tRFC_slr and is specificed as the value as for a monolithic DDR4 SDRAM of
/// equivalent density. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 36 (bits 3~0) and byte 37 (bits 7~0). For 3DS, tFAW time to the same
/// logical rank is defined as tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices
/// only) and specificed as the value as for a monolithic DDR4 SDRAM equivalent
/// density. Each memory channel will have a value. creator: eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 36 (bits 3~0) and byte 37 (bits 7~0). For 3DS, tFAW time to the same
/// logical rank is defined as tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices
/// only) and specificed as the value as for a monolithic DDR4 SDRAM equivalent
/// density. Each memory channel will have a value. creator: eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Four Activate Window Delay Time in nck (number of clock cycles). Decodes
/// SPD byte 36 (bits 3~0) and byte 37 (bits 7~0). For 3DS, tFAW time to the same
/// logical rank is defined as tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices
/// only) and specificed as the value as for a monolithic DDR4 SDRAM equivalent
/// density. Each memory channel will have a value. creator: eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, different bank group in nck (number of
/// clock cycles). Decodes SPD byte 38 (bits 7~0). For 3DS, The tRRD_S time to a
/// different bank group in the same logical rank is defined as tRRD_slr and is
/// specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
/// Each memory channel will have a value. creator: eff_confg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_s(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_S, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, different bank group in nck (number of
/// clock cycles). Decodes SPD byte 38 (bits 7~0). For 3DS, The tRRD_S time to a
/// different bank group in the same logical rank is defined as tRRD_slr and is
/// specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
/// Each memory channel will have a value. creator: eff_confg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_s(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_S, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, different bank group in nck (number of
/// clock cycles). Decodes SPD byte 38 (bits 7~0). For 3DS, The tRRD_S time to a
/// different bank group in the same logical rank is defined as tRRD_slr and is
/// specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
/// Each memory channel will have a value. creator: eff_confg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_s(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_S, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, same bank group in nck (number of clock
/// cycles). Decodes SPD byte 39 (bits 7~0). For 3DS, The tRRD_L time to the same
/// bank group in the same logical rank is defined as tRRD_L_slr and is specificed
/// as the value as for a monolithic DDR4 SDRAM of equivalent density. Each memory
/// channel will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_L, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, same bank group in nck (number of clock
/// cycles). Decodes SPD byte 39 (bits 7~0). For 3DS, The tRRD_L time to the same
/// bank group in the same logical rank is defined as tRRD_L_slr and is specificed
/// as the value as for a monolithic DDR4 SDRAM of equivalent density. Each memory
/// channel will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_l(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_L, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Activate to Activate Delay Time, same bank group in nck (number of clock
/// cycles). Decodes SPD byte 39 (bits 7~0). For 3DS, The tRRD_L time to the same
/// bank group in the same logical rank is defined as tRRD_L_slr and is specificed
/// as the value as for a monolithic DDR4 SDRAM of equivalent density. Each memory
/// channel will have a value. creator: eff_confg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD_L, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCCD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS to CAS Delay Time, same bank group in nck (number of clock cycles).
/// Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0). This is for DDR4 MRS6.
/// Each memory channel will have a value. Creator: eff_config Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCCD_L, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCCD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS to CAS Delay Time, same bank group in nck (number of clock cycles).
/// Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0). This is for DDR4 MRS6.
/// Each memory channel will have a value. Creator: eff_config Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCCD_L, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCCD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS to CAS Delay Time, same bank group in nck (number of clock cycles).
/// Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0). This is for DDR4 MRS6.
/// Each memory channel will have a value. Creator: eff_config Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCCD_L, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write Recovery Time. Decodes SPD byte 41 (bits 3~0) and byte 42 (bits
/// 7~0). Each memory channel will have a value. creator: mss_eff_cnfg_timing
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write Recovery Time. Decodes SPD byte 41 (bits 3~0) and byte 42 (bits
/// 7~0). Each memory channel will have a value. creator: mss_eff_cnfg_timing
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write Recovery Time. Decodes SPD byte 41 (bits 3~0) and byte 42 (bits
/// 7~0). Each memory channel will have a value. creator: mss_eff_cnfg_timing
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, different bank group in nck (number of clock
/// cycles). Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0). Each memory channel
/// will have a value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_s(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_S, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, different bank group in nck (number of clock
/// cycles). Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0). Each memory channel
/// will have a value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_s(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_S, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_S getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, different bank group in nck (number of clock
/// cycles). Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0). Each memory channel
/// will have a value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_s(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_S, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_S: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, same bank group in nck (number of clock cycles).
/// Decodes byte 43 (7~4) and byte 45 (bits 7~0). Each memory channel will have a
/// value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_l(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_L, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, same bank group in nck (number of clock cycles).
/// Decodes byte 43 (7~4) and byte 45 (bits 7~0). Each memory channel will have a
/// value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_l(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_L, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Write to Read Time, same bank group in nck (number of clock cycles).
/// Decodes byte 43 (7~4) and byte 45 (bits 7~0). Each memory channel will have a
/// value. creator: eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr_l(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR_L, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits), X8 (8
/// bits), X16 (16 bits), X32 (32 bits). creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WIDTH, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits), X8 (8
/// bits), X16 (16 bits), X32 (32 bits). creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WIDTH, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  SDRAM Device Width Decodes SPD Byte 12 (bits 2~0). Options: X4 (4 bits), X8 (8
/// bits), X16 (16 bits), X32 (32 bits). creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WIDTH, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total number of ranks in each DIMM. For monolithic and multi-load stack modules
/// (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD Byte 12
/// bits 5~3). For single load stack (3DS) modules this value represents the number
/// of logical ranks per DIMM. Logical rank refers the individually addressable die
/// in a 3DS stack and has no meaning for monolithic or multi-load stacked SDRAMs.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_RANKS_PER_DIMM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total number of ranks in each DIMM. For monolithic and multi-load stack modules
/// (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD Byte 12
/// bits 5~3). For single load stack (3DS) modules this value represents the number
/// of logical ranks per DIMM. Logical rank refers the individually addressable die
/// in a 3DS stack and has no meaning for monolithic or multi-load stacked SDRAMs.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_RANKS_PER_DIMM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total number of ranks in each DIMM. For monolithic and multi-load stack modules
/// (SDP/DDP) this is the same as the number of package ranks per DIMM (SPD Byte 12
/// bits 5~3). For single load stack (3DS) modules this value represents the number
/// of logical ranks per DIMM. Logical rank refers the individually addressable die
/// in a 3DS stack and has no meaning for monolithic or multi-load stacked SDRAMs.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_RANKS_PER_DIMM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_REGISTER_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Type Decodes SPD Byte 131 creator: mss_eff_cnfg consumer:
/// eff_dimm
///
inline fapi2::ReturnCode eff_register_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_REGISTER_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_REGISTER_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_REGISTER_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Type Decodes SPD Byte 131 creator: mss_eff_cnfg consumer:
/// eff_dimm
///
inline fapi2::ReturnCode eff_register_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_REGISTER_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_REGISTER_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_REGISTER_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Type Decodes SPD Byte 131 creator: mss_eff_cnfg consumer:
/// eff_dimm
///
inline fapi2::ReturnCode eff_register_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_REGISTER_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_REGISTER_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MFG_ID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Manufacturer ID Code Decodes SPD Byte 350 and 351 creator: mss_eff_cnfg
/// consumer:
/// power_thermal::decoder
///
inline fapi2::ReturnCode eff_dram_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MFG_ID, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MFG_ID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Manufacturer ID Code Decodes SPD Byte 350 and 351 creator: mss_eff_cnfg
/// consumer:
/// power_thermal::decoder
///
inline fapi2::ReturnCode eff_dram_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MFG_ID, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MFG_ID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Manufacturer ID Code Decodes SPD Byte 350 and 351 creator: mss_eff_cnfg
/// consumer:
/// power_thermal::decoder
///
inline fapi2::ReturnCode eff_dram_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MFG_ID, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RCD_MFG_ID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Manufacturer ID Code Decodes SPD Byte 133 and 134 creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_rcd_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RCD_MFG_ID, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RCD_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RCD_MFG_ID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Manufacturer ID Code Decodes SPD Byte 133 and 134 creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_rcd_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RCD_MFG_ID, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RCD_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RCD_MFG_ID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Manufacturer ID Code Decodes SPD Byte 133 and 134 creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_rcd_mfg_id(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RCD_MFG_ID, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RCD_MFG_ID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_REGISTER_REV getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Revision Number Decodes SPD Byte 135 creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_register_rev(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_REGISTER_REV, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_REGISTER_REV: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_REGISTER_REV getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Revision Number Decodes SPD Byte 135 creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_register_rev(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_REGISTER_REV, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_REGISTER_REV: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_REGISTER_REV getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Revision Number Decodes SPD Byte 135 creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_register_rev(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_REGISTER_REV, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_REGISTER_REV: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PACKAGE_RANK_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Package Rank Map Decodes SPD Byte 60 - 77 (Bits 7~6) creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_package_rank_map(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][18];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PACKAGE_RANK_MAP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 18);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PACKAGE_RANK_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PACKAGE_RANK_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Package Rank Map Decodes SPD Byte 60 - 77 (Bits 7~6) creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_package_rank_map(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][18];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PACKAGE_RANK_MAP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 36);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PACKAGE_RANK_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PACKAGE_RANK_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Package Rank Map Decodes SPD Byte 60 - 77 (Bits 7~6) creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_package_rank_map(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][18];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PACKAGE_RANK_MAP, i_target, l_value) );
    memcpy(o_array, &l_value, 72);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PACKAGE_RANK_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NIBBLE_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Nibble Map Decodes SPD Byte 60 - 77 (Bits 5~0) creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_nibble_map(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][18];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NIBBLE_MAP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 18);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NIBBLE_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NIBBLE_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Nibble Map Decodes SPD Byte 60 - 77 (Bits 5~0) creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_nibble_map(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][18];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NIBBLE_MAP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 36);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NIBBLE_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NIBBLE_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Nibble Map Decodes SPD Byte 60 - 77 (Bits 5~0) creator:
/// mss_eff_cnfg
///
inline fapi2::ReturnCode eff_nibble_map(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][18];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NIBBLE_MAP, i_target, l_value) );
    memcpy(o_array, &l_value, 72);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NIBBLE_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook safe mode throttle value for numerator
/// cfg_nm_n_per_port Set to below optimum value/ rate. On a per port (MCA) basis
/// Also used for emergency mode throttle MBA_FARB4Q_EMERGENCY_N Used to thermally
/// protect the system in all supported environmental conditions when OCC is not
/// functional Consumer: thermal_init,
/// initfile
///
inline fapi2::ReturnCode mrw_safemode_mem_throttled_n_commands_per_port(uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT getter
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Thermal Memory Power Limit Used to calculate throttles
/// to be at or under the power limit Per DIMM basis KEY (0-19): In order DIMM_SIZE
/// = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY =
/// 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits
/// 21-32: Not used VALUE (bits 32-63) in cW: VMEM+VPP thermal power limit per DIMM
/// = 32-63 Consumers: eff_config_thermal and
/// bulk_pwr_throttles
///
inline fapi2::ReturnCode mrw_thermal_memory_power_limit(uint64_t* o_array)
{
    uint64_t l_value[10];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            l_value) );
    memcpy(o_array, &l_value, 80);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PWR_INTERCEPT getter
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Power Curve Intercept for DIMM Used to get the VDDR
/// and VDDR+VPP power curve for each DIMM Decoded and used to set
/// ATTR_MSS_TOTAL_PWR_INTERCEPT Key Value pair KEY (0-19): In order DIMM_SIZE =
/// bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY =
/// 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits
/// 21-32: Not used VALUE (bits 32-63) in cW: VMEM power curve = 32-47 VMEM+VPP
/// power curve = 48-63 Consumers:
/// eff_config_thermal
///
inline fapi2::ReturnCode mrw_pwr_intercept(uint64_t* o_array)
{
    uint64_t l_value[100];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PWR_INTERCEPT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 800);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_PWR_INTERCEPT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PWR_SLOPE getter
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Power Curve Slope for DIMM Used to get the VDDR and
/// VDDR+VPP power curve for each DIMM Decoded and used to set
/// ATTR_MSS_TOTAL_PWR_INTERCEPT Key Value pair KEY (0-19): In order DIMM_SIZE =
/// bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY =
/// 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits
/// 21-32: Not used VALUE (bits 32-63) in cW: VMEM power curve = 32-47 VMEM+VPP
/// power curve = 48-63 Consumers:
/// eff_config_thermal
///
inline fapi2::ReturnCode mrw_pwr_slope(uint64_t* o_array)
{
    uint64_t l_value[100];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PWR_SLOPE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 800);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_PWR_SLOPE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_REFRESH_RATE_REQUEST getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Refresh Rate Desired refresh interval used in refresh
/// register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us (SINGLE) 3.9 us (DOUBLE) 7.02
/// us (SINGLE_10_PERCENT_FASTER) 3.51 us
/// (DOUBLE_10_PERCENT_FASTER)
///
inline fapi2::ReturnCode mrw_refresh_rate_request(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_REFRESH_RATE_REQUEST, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_REFRESH_RATE_REQUEST: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook DIMM power curve percent uplift for this system at max
/// utilization. Value should be 0 for
/// ISDIMMs
///
inline fapi2::ReturnCode mrw_dimm_power_curve_percent_uplift(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook DIMM power curve percent uplift for this system at
/// idle utilization. Value should be 0 for
/// ISDIMMs
///
inline fapi2::ReturnCode mrw_dimm_power_curve_percent_uplift_idle(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook for the number of M DRAM clocks. One approach to
/// curbing DRAM power usage is by throttling traffic through a programmable N
/// commands over M
/// window.
///
inline fapi2::ReturnCode mrw_mem_m_dram_clocks(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value for maximum dram data bus utilization in centi
/// percent (c%). Used to determine memory throttle values. Max databus utilization
/// on a per port basis Default to
/// 90%
///
inline fapi2::ReturnCode mrw_max_dram_databus_util(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory power control settings for IDLE powersave mode Used by OCC when entering
/// idle power-save
/// mode
///
inline fapi2::ReturnCode mrw_idle_power_control_requested(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4 getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook VMEM regulator power limit per DIMM assuming a full
/// configuration. Units in cW Consumed in
/// mss_eff_config_thermal
///
inline fapi2::ReturnCode mrw_vmem_regulator_power_limit_per_dimm_ddr4(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value for the maximum possible number of dimms that
/// can be installed under any of the VMEM regulators. Consumed in
/// eff_config_thermal to calculate
/// mem_watt_target
///
inline fapi2::ReturnCode mrw_max_number_dimms_possible_per_vmem_regulator(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_FINE_REFRESH_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From JEDEC DDR4 Spec
/// 1716.78C from 07-2016 Page 47 Table
/// 4.9.1
///
inline fapi2::ReturnCode mrw_fine_refresh_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_FINE_REFRESH_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_FINE_REFRESH_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_TEMP_REFRESH_RANGE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature refresh range. Sets DDR4 MRS4. Should be defaulted to extended
/// range. NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less
/// degrees C Used for calculating periodic refresh intervals JEDEC DDR4 spec
/// 1716.78C from 07-2016 page 46
/// 4.8.1
///
inline fapi2::ReturnCode mrw_temp_refresh_range(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_TEMP_REFRESH_RANGE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_TEMP_REFRESH_RANGE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  For resetting the phy delay values at the beginning of calling
/// mss_draminit_training. YES means the vaules will be
/// reset.
///
inline fapi2::ReturnCode mrw_reset_delay_before_cal(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS getter
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Describes the settings for periodic calibration for all ports: Reading left to
/// right. (DEFAULT: 0xD90C -> Byte 0(11011001), Byte 1(00001100)) For each bit: OFF
/// = 0, ON = 1. Setting to 0 indicates to disable periodic memcal. Byte 0: 0: ZCAL
/// 1: SYSCK_ALIGN 2: RDCENTERING 3: RDLCK_ALIGN 4: DQS_ALIGN 5: RDCLK_UPDATE 6:
/// PER_DUTYCYCLE 7: PERCAL_PWR_DIS Byte 1: 0: PERCAL_REPEAT 1: PERCAL_REPEAT 2:
/// PERCAL_REPEAT 3: SINGLE_BIT_MPR 4: MBA_CFG_0 5: MBA_CFG_1 6: SPARE 7:
/// SPARE
///
inline fapi2::ReturnCode mrw_periodic_memcal_mode_options(uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS getter
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Describes the settings for periodic ZQ calibration for all ports: Reading left
/// to right. For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable
/// periodic zqcal. Byte 0: 0: ZQCAL All others reserved for future
/// use
///
inline fapi2::ReturnCode mrw_periodic_zqcal_mode_options(uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DRAM_2N_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Allows user to manually turn on and off 2N Mode. AUTO indicates to use Signal
/// Integrity generated setting (from
/// VPD).
///
inline fapi2::ReturnCode mrw_dram_2n_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DRAM_2N_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_DRAM_2N_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Each MCA value is a 64-bit vector, where each byte represents an unsupported
/// rank configuration. Each nibble in the byte represents the total count of ranks
/// (master and slave) on each DIMM. The left-most nibble represents slot 0 and the
/// right represents
/// 1.
///
inline fapi2::ReturnCode mrw_unsupported_rank_config(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Each MCA value is a 64-bit vector, where each byte represents an unsupported
/// rank configuration. Each nibble in the byte represents the total count of ranks
/// (master and slave) on each DIMM. The left-most nibble represents slot 0 and the
/// right represents
/// 1.
///
inline fapi2::ReturnCode mrw_unsupported_rank_config(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Each MCA value is a 64-bit vector, where each byte represents an unsupported
/// rank configuration. Each nibble in the byte represents the total count of ranks
/// (master and slave) on each DIMM. The left-most nibble represents slot 0 and the
/// right represents
/// 1.
///
inline fapi2::ReturnCode mrw_unsupported_rank_config(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DRAM_WRITE_CRC getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables DRAM Write
/// CRC
///
inline fapi2::ReturnCode mrw_dram_write_crc(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DRAM_WRITE_CRC, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_DRAM_WRITE_CRC: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_TEMP_REFRESH_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used in MR4 A3 Temperature refresh mode Should be defaulted to
/// disable
///
inline fapi2::ReturnCode mrw_temp_refresh_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_TEMP_REFRESH_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_TEMP_REFRESH_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_FORCE_BCMODE_OFF getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  An override switch to shut off broadcast mode Enum values: YES: broadcast mode
/// is forced off NO: broadcast mode uses the default
/// value
///
inline fapi2::ReturnCode mrw_force_bcmode_off(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_FORCE_BCMODE_OFF, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_FORCE_BCMODE_OFF: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_NVDIMM_PLUG_RULES getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bitmap containing the plug rules for NVDIMM. 1 if a DIMM supports an NVDIMM
/// being plugged in, 0 if it does not DIMM slot 0 is the left most bit The index to
/// the bitmap is the position of the DIMM target As such, a bitmap of 0b10010000,
/// would allow NVDIMM plugged into DIMM0 and DIMM3 Note: this attribute is a 64 bit
/// number to account for 16 DIMM per processor if there is ever a 4 processor
/// system
///
inline fapi2::ReturnCode mrw_nvdimm_plug_rules(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_NVDIMM_PLUG_RULES, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_NVDIMM_PLUG_RULES: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Switch that allows unsupported raw card references by providing a default raw
/// card
/// setting.
///
inline fapi2::ReturnCode mrw_allow_unsupported_rcw(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bitmap of DRAM widths supported by a system. A 1 indicates that the system
/// supports a density. Enums below represent the the bit location in the attribute
/// for a given DRAM width. Default value is 0xC -> both x4/x8
/// supported
///
inline fapi2::ReturnCode mrw_supported_dram_width(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_VPD_MR_0_VERSION_LAYOUT getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MR Keyword Layout Version Number. Increases when attributes are added, removed,
/// or redefined. Does not
/// reset.
///
inline fapi2::ReturnCode vpd_mr_0_version_layout(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_0_VERSION_LAYOUT, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_0_VERSION_LAYOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_1_VERSION_DATA getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MR Keyword Data Version Number. Increases when data changes with the above
/// layout version. Resets when layout version number
/// increments.
///
inline fapi2::ReturnCode vpd_mr_1_version_data(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_1_VERSION_DATA, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_1_VERSION_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_2_SIGNATURE_HASH getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hash Signature for the MT Keyword. The hash signature is 32bits for 256 bytes of
/// data.
///
inline fapi2::ReturnCode vpd_mr_2_signature_hash(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_2_SIGNATURE_HASH, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_2_SIGNATURE_HASH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Global phy offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_gpo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_GPO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Global phy offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_gpo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_GPO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Global phy offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_gpo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_GPO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read latency offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_rlo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_RLO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read latency offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_rlo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_RLO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read latency offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_rlo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_RLO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write latency offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_wlo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_WLO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write latency offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_wlo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_WLO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_DPHY_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write latency offset in number of
/// clocks
///
inline fapi2::ReturnCode vpd_mr_dphy_wlo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_DPHY_WLO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_DPHY_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Default value for 2N Mode from Signal Integrity. 0x01 = 1N Mode , 0x02 = 2N
/// Mode
///
inline fapi2::ReturnCode vpd_mr_mc_2n_mode_autoset(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a00(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a00(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a01(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a01(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a01(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a02(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a02(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a03(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a03(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a04(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a04(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a05(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a05(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a06(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a06(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a06(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a07(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a07(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a07(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a08(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a08(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a08(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a09(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a09(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a09(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of command/address of A## in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Address of BA# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BG# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BG# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BG# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BA# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BA# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Bank Group of BA# in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip ID of C# in ticks. Only used in TSV Dimms.
/// Ticks are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Activate for ACTN in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Activate for ACTN in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Activate for ACTN in ticks. Ticks are 1/128 of one
/// cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Column Access Strobe for CASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Column Access Strobe for CASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Column Access Strobe for CASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Row Access Strobe for RASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Row Access Strobe for RASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Row Access Strobe for RASN in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Write Enable for WEN in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Write Enable for WEN in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Write Enable for WEN in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of the Parity Input for PAR in ticks. Ticks are 1/128
/// of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of the Parity Input for PAR in ticks. Ticks are 1/128
/// of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of the Parity Input for PAR in ticks. Ticks are 1/128
/// of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d0_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock Enable for Dimm#_CKE# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are
/// 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks
/// are 1/128 of one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_d1_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkn(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkn(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkn(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d0_clkp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkn(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkn(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkn(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of
/// one cycle of
/// clock.
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_d1_clkp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_TSYS_ADR getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ADR WRClk Phase Rotator Offset Value in ticks. Ticks are 1/128 of one cycle of
/// clock. Phase Rotator Static Offset value used to determine the Phase of the
/// WrClk with respect to SysClk. For zero delay simulations, or simulations where
/// the delay of the SysClk tree and the WrClk tree are equal, Set this field to
/// 60h
///
inline fapi2::ReturnCode vpd_mr_tsys_adr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_TSYS_ADR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_TSYS_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MR_TSYS_DATA getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DP16 WrClk Phase Rotator Offset Value in ticks. Ticks are 1/128 of one cycle of
/// clock. Phase Rotator Static Offset value used to determine the Phase of the
/// WrClk with respect to SysClk. For zero delay simulations, or simulations where
/// the delay of the SysClk tree and the WrClk tree are equal, Set this field to
/// 60h
///
inline fapi2::ReturnCode vpd_mr_tsys_data(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MR_TSYS_DATA, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MR_TSYS_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_VPD_MT_0_VERSION_LAYOUT getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MT Keyword Layout Version Number. Increases when attributes are added, removed,
/// or redefined. Does not
/// reset.
///
inline fapi2::ReturnCode vpd_mt_0_version_layout(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_0_VERSION_LAYOUT, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_0_VERSION_LAYOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_1_VERSION_DATA getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MT Keyword Data Version Number. Increases when data changes with the above
/// layout version. Resets when layout version number
/// increments.
///
inline fapi2::ReturnCode vpd_mt_1_version_data(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_1_VERSION_DATA, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_1_VERSION_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_2_SIGNATURE_HASH getter
/// @param[in] const ref to the TARGET_TYPE_MCS
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (NODIM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hash Signature for the MT Keyword. The hash signature is 32bits for 256 bytes of
/// data.
///
inline fapi2::ReturnCode vpd_mt_2_signature_hash(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_2_SIGNATURE_HASH, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_2_SIGNATURE_HASH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Command/Address in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Command/Address in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Command/Address in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_ca(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Clock Enable in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Clock Enable in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Clock Enable in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cke(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Chip Select in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Chip Select in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for Chip Select in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_cs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for On Die Termination in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for On Die Termination in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Register Clock Driver, Input Bus Termination for On Die Termination in tens of
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt_odt(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQ and DQS Drive Impedance for
/// [Port][DIMM][RANK].
///
inline fapi2::ReturnCode vpd_mt_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQ and DQS Drive Impedance for
/// [Port][DIMM][RANK].
///
inline fapi2::ReturnCode vpd_mt_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQ and DQS Drive Impedance for
/// [Port][DIMM][RANK].
///
inline fapi2::ReturnCode vpd_mt_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Nominal Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Nominal Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Nominal Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_NOM, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Park Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Park Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Park Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_PARK, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Termination Resistance in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_DRAM_RTT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_BIAS_TRIM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Adjusts the receiver internal current bias. ONLY set range 0-7. Default value is
/// 3. [VPD Value] = [Binary bit value set in register] 0 = 110 (Minimal power) 1 =
/// 010 2 = 100 3 = 000 (Default) 4 = 111 5 = 011 6 = 101 7 = 001 (Maximum
/// power)
///
inline fapi2::ReturnCode vpd_mt_mc_bias_trim(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_BIAS_TRIM, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_BIAS_TRIM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_BIAS_TRIM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Adjusts the receiver internal current bias. ONLY set range 0-7. Default value is
/// 3. [VPD Value] = [Binary bit value set in register] 0 = 110 (Minimal power) 1 =
/// 010 2 = 100 3 = 000 (Default) 4 = 111 5 = 011 6 = 101 7 = 001 (Maximum
/// power)
///
inline fapi2::ReturnCode vpd_mt_mc_bias_trim(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_BIAS_TRIM, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_BIAS_TRIM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_BIAS_TRIM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Adjusts the receiver internal current bias. ONLY set range 0-7. Default value is
/// 3. [VPD Value] = [Binary bit value set in register] 0 = 110 (Minimal power) 1 =
/// 010 2 = 100 3 = 000 (Default) 4 = 111 5 = 011 6 = 101 7 = 001 (Maximum
/// power)
///
inline fapi2::ReturnCode vpd_mt_mc_bias_trim(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_BIAS_TRIM, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_BIAS_TRIM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during READ mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_rd_up(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during READ mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_rd_up(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during READ mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_rd_up(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pulldown branches during WRITE mode. ONLY set
/// range 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches
/// selected) Bit 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits
/// 8-15) Bit 6-8 = DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits
/// 8-15) Bit 12-14 = DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits
/// 8-15) Bit 18-20 = DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits
/// 8-15) Bit 24-26 = DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_down(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pulldown branches during WRITE mode. ONLY set
/// range 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches
/// selected) Bit 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits
/// 8-15) Bit 6-8 = DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits
/// 8-15) Bit 12-14 = DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits
/// 8-15) Bit 18-20 = DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits
/// 8-15) Bit 24-26 = DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_down(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pulldown branches during WRITE mode. ONLY set
/// range 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches
/// selected) Bit 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits
/// 8-15) Bit 6-8 = DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits
/// 8-15) Bit 12-14 = DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits
/// 8-15) Bit 18-20 = DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits
/// 8-15) Bit 24-26 = DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_down(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during WRITE mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_up(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during WRITE mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_up(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the number of enabled pullup branches during WRITE mode. ONLY set range
/// 0-7. Eg. 0x02 = b010 (1 branch selected), 0x06 = b110 (2 branches selected) Bit
/// 0-2 = DP16 Block 0 (DQ Bits 0-7) Bit 3-5 = DP16 Block 0 (DQ Bits 8-15) Bit 6-8 =
/// DP16 Block 1 (DQ Bits 0-7) Bit 9-11 = DP16 Block 1 (DQ Bits 8-15) Bit 12-14 =
/// DP16 Block 2 (DQ Bits 0-7) Bit 15-17 = DP16 Block 2 (DQ Bits 8-15) Bit 18-20 =
/// DP16 Block 3 (DQ Bits 0-7) Bit 21-23 = DP16 Block 3 (DQ Bits 8-15) Bit 24-26 =
/// DP16 Block 4 (DQ Bits 0-7) Bit 27-29 = DP16 Block 4 (DQ Bits
/// 8-15)
///
inline fapi2::ReturnCode vpd_mt_mc_dq_acboost_wr_up(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the capacitance value in the RC source degeneration. ONLY set range 0-3.
/// (b00 = No capacitor selected, b01 = more caps selected, b10 = even more caps
/// selected, b11 = maximum capacitors selected) Bit 0-1 = DP16 Block 0 Nibble 0 Bit
/// 16-17 = DP16 Block 2 Nibble 0 Bit 32-33 = DP16 Block 4 Nibble 0 Bit 2-3 = DP16
/// Block 0 Nibble 1 Bit 18-19 = DP16 Block 2 Nibble 1 Bit 34-35 = DP16 Block 4
/// Nibble 1 Bit 4-5 = DP16 Block 0 Nibble 2 Bit 20-21 = DP16 Block 2 Nibble 2 Bit
/// 36-37 = DP16 Block 4 Nibble 2 Bit 6-7 = DP16 Block 0 Nibble 3 Bit 22-23 = DP16
/// Block 2 Nibble 3 Bit 38-39 = DP16 Block 4 Nibble 3 Bit 8-9 = DP16 Block 1 Nibble
/// 0 Bit 24-25 = DP16 Block 3 Nibble 0 Bit 10-11 = DP16 Block 1 Nibble 1 Bit 26-27
/// = DP16 Block 3 Nibble 1 Bit 12-13 = DP16 Block 1 Nibble 2 Bit 28-29 = DP16 Block
/// 3 Nibble 2 Bit 14-15 = DP16 Block 1 Nibble 3 Bit 30-31 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_cap(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the capacitance value in the RC source degeneration. ONLY set range 0-3.
/// (b00 = No capacitor selected, b01 = more caps selected, b10 = even more caps
/// selected, b11 = maximum capacitors selected) Bit 0-1 = DP16 Block 0 Nibble 0 Bit
/// 16-17 = DP16 Block 2 Nibble 0 Bit 32-33 = DP16 Block 4 Nibble 0 Bit 2-3 = DP16
/// Block 0 Nibble 1 Bit 18-19 = DP16 Block 2 Nibble 1 Bit 34-35 = DP16 Block 4
/// Nibble 1 Bit 4-5 = DP16 Block 0 Nibble 2 Bit 20-21 = DP16 Block 2 Nibble 2 Bit
/// 36-37 = DP16 Block 4 Nibble 2 Bit 6-7 = DP16 Block 0 Nibble 3 Bit 22-23 = DP16
/// Block 2 Nibble 3 Bit 38-39 = DP16 Block 4 Nibble 3 Bit 8-9 = DP16 Block 1 Nibble
/// 0 Bit 24-25 = DP16 Block 3 Nibble 0 Bit 10-11 = DP16 Block 1 Nibble 1 Bit 26-27
/// = DP16 Block 3 Nibble 1 Bit 12-13 = DP16 Block 1 Nibble 2 Bit 28-29 = DP16 Block
/// 3 Nibble 2 Bit 14-15 = DP16 Block 1 Nibble 3 Bit 30-31 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_cap(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the capacitance value in the RC source degeneration. ONLY set range 0-3.
/// (b00 = No capacitor selected, b01 = more caps selected, b10 = even more caps
/// selected, b11 = maximum capacitors selected) Bit 0-1 = DP16 Block 0 Nibble 0 Bit
/// 16-17 = DP16 Block 2 Nibble 0 Bit 32-33 = DP16 Block 4 Nibble 0 Bit 2-3 = DP16
/// Block 0 Nibble 1 Bit 18-19 = DP16 Block 2 Nibble 1 Bit 34-35 = DP16 Block 4
/// Nibble 1 Bit 4-5 = DP16 Block 0 Nibble 2 Bit 20-21 = DP16 Block 2 Nibble 2 Bit
/// 36-37 = DP16 Block 4 Nibble 2 Bit 6-7 = DP16 Block 0 Nibble 3 Bit 22-23 = DP16
/// Block 2 Nibble 3 Bit 38-39 = DP16 Block 4 Nibble 3 Bit 8-9 = DP16 Block 1 Nibble
/// 0 Bit 24-25 = DP16 Block 3 Nibble 0 Bit 10-11 = DP16 Block 1 Nibble 1 Bit 26-27
/// = DP16 Block 3 Nibble 1 Bit 12-13 = DP16 Block 1 Nibble 2 Bit 28-29 = DP16 Block
/// 3 Nibble 2 Bit 14-15 = DP16 Block 1 Nibble 3 Bit 30-31 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_cap(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the resistance value in the RC source degeneration. Also defines the CTLE's
/// DC Gain. ONLY set range 0-7. (b000 = max resistance, b001 to b110 = decreasing
/// resistance, b111 = min resistance) Bit 0-2 = DP16 Block 0 Nibble 0 Bit 24-26 =
/// DP16 Block 2 Nibble 0 Bit 48-50 = DP16 Block 4 Nibble 0 Bit 3-5 = DP16 Block 0
/// Nibble 1 Bit 27-29 = DP16 Block 2 Nibble 1 Bit 51-53 = DP16 Block 4 Nibble 1 Bit
/// 6-8 = DP16 Block 0 Nibble 2 Bit 30-32 = DP16 Block 2 Nibble 2 Bit 54-56 = DP16
/// Block 4 Nibble 2 Bit 9-11 = DP16 Block 0 Nibble 3 Bit 33-35 = DP16 Block 2
/// Nibble 3 Bit 57-59 = DP16 Block 4 Nibble 3 Bit 12-14 = DP16 Block 1 Nibble 0 Bit
/// 36-38 = DP16 Block 3 Nibble 0 Bit 15-17 = DP16 Block 1 Nibble 1 Bit 39-41 = DP16
/// Block 3 Nibble 1 Bit 18-20 = DP16 Block 1 Nibble 2 Bit 42-44 = DP16 Block 3
/// Nibble 2 Bit 21-23 = DP16 Block 1 Nibble 3 Bit 45-47 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_res(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the resistance value in the RC source degeneration. Also defines the CTLE's
/// DC Gain. ONLY set range 0-7. (b000 = max resistance, b001 to b110 = decreasing
/// resistance, b111 = min resistance) Bit 0-2 = DP16 Block 0 Nibble 0 Bit 24-26 =
/// DP16 Block 2 Nibble 0 Bit 48-50 = DP16 Block 4 Nibble 0 Bit 3-5 = DP16 Block 0
/// Nibble 1 Bit 27-29 = DP16 Block 2 Nibble 1 Bit 51-53 = DP16 Block 4 Nibble 1 Bit
/// 6-8 = DP16 Block 0 Nibble 2 Bit 30-32 = DP16 Block 2 Nibble 2 Bit 54-56 = DP16
/// Block 4 Nibble 2 Bit 9-11 = DP16 Block 0 Nibble 3 Bit 33-35 = DP16 Block 2
/// Nibble 3 Bit 57-59 = DP16 Block 4 Nibble 3 Bit 12-14 = DP16 Block 1 Nibble 0 Bit
/// 36-38 = DP16 Block 3 Nibble 0 Bit 15-17 = DP16 Block 1 Nibble 1 Bit 39-41 = DP16
/// Block 3 Nibble 1 Bit 18-20 = DP16 Block 1 Nibble 2 Bit 42-44 = DP16 Block 3
/// Nibble 2 Bit 21-23 = DP16 Block 1 Nibble 3 Bit 45-47 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_res(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Sets the resistance value in the RC source degeneration. Also defines the CTLE's
/// DC Gain. ONLY set range 0-7. (b000 = max resistance, b001 to b110 = decreasing
/// resistance, b111 = min resistance) Bit 0-2 = DP16 Block 0 Nibble 0 Bit 24-26 =
/// DP16 Block 2 Nibble 0 Bit 48-50 = DP16 Block 4 Nibble 0 Bit 3-5 = DP16 Block 0
/// Nibble 1 Bit 27-29 = DP16 Block 2 Nibble 1 Bit 51-53 = DP16 Block 4 Nibble 1 Bit
/// 6-8 = DP16 Block 0 Nibble 2 Bit 30-32 = DP16 Block 2 Nibble 2 Bit 54-56 = DP16
/// Block 4 Nibble 2 Bit 9-11 = DP16 Block 0 Nibble 3 Bit 33-35 = DP16 Block 2
/// Nibble 3 Bit 57-59 = DP16 Block 4 Nibble 3 Bit 12-14 = DP16 Block 1 Nibble 0 Bit
/// 36-38 = DP16 Block 3 Nibble 0 Bit 15-17 = DP16 Block 1 Nibble 1 Bit 39-41 = DP16
/// Block 3 Nibble 1 Bit 18-20 = DP16 Block 1 Nibble 2 Bit 42-44 = DP16 Block 3
/// Nibble 2 Bit 21-23 = DP16 Block 1 Nibble 3 Bit 45-47 = DP16 Block 3 Nibble
/// 3
///
inline fapi2::ReturnCode vpd_mt_mc_dq_ctle_res(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Address, Bank Address, Bank Group and
/// Activate Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Address, Bank Address, Bank Group and
/// Activate Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Address, Bank Address, Bank Group and
/// Activate Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cmd_addr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock Enable, ODT, Parity, and Reset
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock Enable, ODT, Parity, and Reset
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Clock Enable, ODT, Parity, and Reset
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cscid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cscid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cscid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][5];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][5];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 5);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Drive Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][5];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 10);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Receiver Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][5];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Receiver Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][5];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 5);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Receiver Impedance for [PORT][DP16] Data and Data Strobe
/// Lines in
/// Ohms.
///
inline fapi2::ReturnCode vpd_mt_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][5];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 10);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  READ, On Die Termination triggering bitmap. Use bitmap to determine which ODT to
/// fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1
/// ODT1][N/A][N/A]
///
inline fapi2::ReturnCode vpd_mt_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_RD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  READ, On Die Termination triggering bitmap. Use bitmap to determine which ODT to
/// fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1
/// ODT1][N/A][N/A]
///
inline fapi2::ReturnCode vpd_mt_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_RD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  READ, On Die Termination triggering bitmap. Use bitmap to determine which ODT to
/// fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1
/// ODT1][N/A][N/A]
///
inline fapi2::ReturnCode vpd_mt_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_RD, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  WRITE, On Die Termination triggering bitmap. Use bitmap to determine which ODT
/// to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1
/// ODT1][N/A][N/A]
///
inline fapi2::ReturnCode vpd_mt_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  WRITE, On Die Termination triggering bitmap. Use bitmap to determine which ODT
/// to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1
/// ODT1][N/A][N/A]
///
inline fapi2::ReturnCode vpd_mt_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  WRITE, On Die Termination triggering bitmap. Use bitmap to determine which ODT
/// to fire for the designated rank. The bits in 8 bit field are [Dimm0 ODT0][Dimm0
/// ODT1][N/A][N/A][Dimm1 ODT0][Dimm1
/// ODT1][N/A][N/A]
///
inline fapi2::ReturnCode vpd_mt_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_ODT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of clocks used for read/write preamble. Calibration only uses 1 nCK
/// preamble (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble option. The value
/// of "0" means 1 nCK preamble, the value of "1" means 2 nCK preamble. Bit 3 for
/// READ preamble, and Bit 7 for WRITE preamble. E.g. 0b00010001 means 2 nCK
/// preamble for both READ and
/// WRITE
///
inline fapi2::ReturnCode vpd_mt_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_PREAMBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of clocks used for read/write preamble. Calibration only uses 1 nCK
/// preamble (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble option. The value
/// of "0" means 1 nCK preamble, the value of "1" means 2 nCK preamble. Bit 3 for
/// READ preamble, and Bit 7 for WRITE preamble. E.g. 0b00010001 means 2 nCK
/// preamble for both READ and
/// WRITE
///
inline fapi2::ReturnCode vpd_mt_preamble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_PREAMBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of clocks used for read/write preamble. Calibration only uses 1 nCK
/// preamble (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble option. The value
/// of "0" means 1 nCK preamble, the value of "1" means 2 nCK preamble. Bit 3 for
/// READ preamble, and Bit 7 for WRITE preamble. E.g. 0b00010001 means 2 nCK
/// preamble for both READ and
/// WRITE
///
inline fapi2::ReturnCode vpd_mt_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_PREAMBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Vref setting for DDR4. Bit encode is 01234567. Bit 0 is unused.
/// Bit 1 is the Range. Bits 2-7 is the Value. Refer to the VrefDQ Training Table in
/// JEDEC.
///
inline fapi2::ReturnCode vpd_mt_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_DRAM_WR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Vref setting for DDR4. Bit encode is 01234567. Bit 0 is unused.
/// Bit 1 is the Range. Bits 2-7 is the Value. Refer to the VrefDQ Training Table in
/// JEDEC.
///
inline fapi2::ReturnCode vpd_mt_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_DRAM_WR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM side Write Vref setting for DDR4. Bit encode is 01234567. Bit 0 is unused.
/// Bit 1 is the Range. Bits 2-7 is the Value. Refer to the VrefDQ Training Table in
/// JEDEC.
///
inline fapi2::ReturnCode vpd_mt_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_DRAM_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_MC_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage
/// of
/// Vdd
///
inline fapi2::ReturnCode vpd_mt_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_MC_RD, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_MC_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage
/// of
/// Vdd
///
inline fapi2::ReturnCode vpd_mt_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_MC_RD, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_VREF_MC_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage
/// of
/// Vdd
///
inline fapi2::ReturnCode vpd_mt_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_VREF_MC_RD, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_WINDAGE_RD_CTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value int16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Derived from calibration/characterization of read centering. Number of windage
/// offset in units of pico-seconds[ps]. Default is 0 Specification of the value in
/// this file is 2's compliment
/// hex
///
inline fapi2::ReturnCode vpd_mt_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, int16_t& o_value)
{
    int16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_WINDAGE_RD_CTR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_WINDAGE_RD_CTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value int16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Derived from calibration/characterization of read centering. Number of windage
/// offset in units of pico-seconds[ps]. Default is 0 Specification of the value in
/// this file is 2's compliment
/// hex
///
inline fapi2::ReturnCode vpd_mt_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, int16_t& o_value)
{
    int16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_WINDAGE_RD_CTR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_MT_WINDAGE_RD_CTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] int16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Derived from calibration/characterization of read centering. Number of windage
/// offset in units of pico-seconds[ps]. Default is 0 Specification of the value in
/// this file is 2's compliment
/// hex
///
inline fapi2::ReturnCode vpd_mt_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, int16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    int16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_MT_WINDAGE_RD_CTR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_MT_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_VPD_CKE_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The Memory Clock Enable MAP is a bit map describing the Memory Clock Enable
/// signal to its respective rank. There are 8 bits, but only 4 are currently used
/// [DIMM0 CKE0][DIMM0 CKE1][N/A][N/A][DIMM1 CKE0][DIMM1 CKE1][N/A][N/A] E.g. 0x80
/// -> 0b10000000, which means DIMM0 CKE0 is mapped to that
/// rank.
///
inline fapi2::ReturnCode vpd_cke_map(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_CKE_MAP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_CKE_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_CKE_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The Memory Clock Enable MAP is a bit map describing the Memory Clock Enable
/// signal to its respective rank. There are 8 bits, but only 4 are currently used
/// [DIMM0 CKE0][DIMM0 CKE1][N/A][N/A][DIMM1 CKE0][DIMM1 CKE1][N/A][N/A] E.g. 0x80
/// -> 0b10000000, which means DIMM0 CKE0 is mapped to that
/// rank.
///
inline fapi2::ReturnCode vpd_cke_map(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_CKE_MAP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_CKE_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_CKE_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The Memory Clock Enable MAP is a bit map describing the Memory Clock Enable
/// signal to its respective rank. There are 8 bits, but only 4 are currently used
/// [DIMM0 CKE0][DIMM0 CKE1][N/A][N/A][DIMM1 CKE0][DIMM1 CKE1][N/A][N/A] E.g. 0x80
/// -> 0b10000000, which means DIMM0 CKE0 is mapped to that
/// rank.
///
inline fapi2::ReturnCode vpd_cke_map(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_CKE_MAP, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_CKE_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_VPD_DQ_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  [PORT][Dimm DQ PIN] The map from the Dual Inline Memory Module (DIMM) Data (DQ)
/// Pin to the Module Package Data (DQ)
/// Pinout
///
inline fapi2::ReturnCode vpd_dq_map(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][72];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_DQ_MAP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 72);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_DQ_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPD_DQ_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  [PORT][Dimm DQ PIN] The map from the Dual Inline Memory Module (DIMM) Data (DQ)
/// Pin to the Module Package Data (DQ)
/// Pinout
///
inline fapi2::ReturnCode vpd_dq_map(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][72];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPD_DQ_MAP, i_target, l_value) );
    memcpy(o_array, &l_value, 144);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPD_DQ_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_BAD_DQ_BITMAP getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (PROC_CHIP)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bad DQ bitmap from a controller point of view. The data is a 10 byte bitmap for
/// each of 4 possible ranks. The bad DQ data is stored in NVRAM, and it is stored
/// in a special format translated to a DIMM Connector point of view. All of these
/// details are hidden from the user of this
/// attribute.
///
inline fapi2::ReturnCode bad_dq_bitmap(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[4][10];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_BAD_DQ_BITMAP, i_target, l_value) );
    memcpy(o_array, &l_value, 40);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_BAD_DQ_BITMAP: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_OVERRIDE_MEMDIAGS_BCMODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A switch for memdiags broadcast
/// mode
///
inline fapi2::ReturnCode override_memdiags_bcmode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_OVERRIDE_MEMDIAGS_BCMODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_OVERRIDE_MEMDIAGS_BCMODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_MAX_ALLOWED_DIMM_FREQ getter
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum frequency (in MHz) that this system can run the DIMMs at. There are 5
/// possible values determined by the dimm configuration. For configurations which
/// have mixed rank configurations, the lowest frequency based on ranks of either
/// DIMM is chosen. For example if there was a 1R and a 2R DIMM installed, and 1R
/// dual drop was a lower max freq than 2R dual drop, then the 1R max freq would be
/// the max allowed. [0]=One rank, single drop [1]=Two rank, single drop [2]=Four
/// rank, single drop [3]=One rank, dual drop [4]=Two rank, dual drop A value of
/// zero would indicate an unsupported configuration. Note: Do not use this
/// attribute to limit configurations, it is not checked during plug rules. If you
/// have an unsupported configuration, use the value 0 as the maximum
/// freq.
///
inline fapi2::ReturnCode max_allowed_dimm_freq(uint32_t* o_array)
{
    uint32_t l_value[5];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MAX_ALLOWED_DIMM_FREQ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 20);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MAX_ALLOWED_DIMM_FREQ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_REQUIRED_SYNCH_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specify the system policy to enforce synchronous mode between memory and nest.
/// This drives the value of ATTR_MEM_IN_SYNCH_MODE. UNDETERMINED : Run
/// synchronously if the dimm and nest freq matches ALWAYS : Require matching
/// frequencies and deconfigure memory that does not match the nest NEVER : Do not
/// run synchronously, even if the frequencies
/// match
///
inline fapi2::ReturnCode required_synch_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_REQUIRED_SYNCH_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_REQUIRED_SYNCH_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_IS_SIMULATION getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  env: 1 = Awan/HWSimulator. 0 =
/// Simics/RealHW.
///
inline fapi2::ReturnCode is_simulation(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_IS_SIMULATION, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_IS_SIMULATION: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MNFG_FLAGS getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The manufacturing flags. This is a bitfield. Each bit is a flag and multiple
/// flags can be
/// set
///
inline fapi2::ReturnCode mnfg_flags(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MNFG_FLAGS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MNFG_FLAGS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_FREQ_PB_MHZ getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The frequency of a processor's nest mesh clock, in MHz. This is the same for all
/// chips in the system. Provided by the
/// MRW.
///
inline fapi2::ReturnCode freq_pb_mhz(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_FREQ_PB_MHZ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_FREQ_PB_MHZ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_MRW_IS_PLANAR getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (PROC_CHIP)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Indicates if the DIMM connected to this controller are in a planar
/// configuration
///
inline fapi2::ReturnCode mem_mrw_is_planar(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_MRW_IS_PLANAR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MEM_MRW_IS_PLANAR: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_POWER_CONTROL_REQUESTED getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory power control settings programmed during IPL Used by OCC when exiting
/// idle power-save
/// mode
///
inline fapi2::ReturnCode mrw_power_control_requested(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_POWER_CONTROL_REQUESTED, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MRW_POWER_CONTROL_REQUESTED: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


}

#endif
